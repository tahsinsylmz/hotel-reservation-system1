
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Musteri
 * 
 */
export type Musteri = $Result.DefaultSelection<Prisma.$MusteriPayload>
/**
 * Model Otel
 * 
 */
export type Otel = $Result.DefaultSelection<Prisma.$OtelPayload>
/**
 * Model Oda
 * 
 */
export type Oda = $Result.DefaultSelection<Prisma.$OdaPayload>
/**
 * Model Rezervasyon
 * 
 */
export type Rezervasyon = $Result.DefaultSelection<Prisma.$RezervasyonPayload>
/**
 * Model OdaDurumu
 * 
 */
export type OdaDurumu = $Result.DefaultSelection<Prisma.$OdaDurumuPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Rol: {
  ADMIN: 'ADMIN',
  OTEL_YONETICISI: 'OTEL_YONETICISI',
  MUSTERI: 'MUSTERI'
};

export type Rol = (typeof Rol)[keyof typeof Rol]


export const RezervasyonDurumu: {
  AKTIF: 'AKTIF',
  IPTAL_EDILDI: 'IPTAL_EDILDI',
  TAMAMLANDI: 'TAMAMLANDI'
};

export type RezervasyonDurumu = (typeof RezervasyonDurumu)[keyof typeof RezervasyonDurumu]


export const OdaDurumTipi: {
  MUSAIT: 'MUSAIT',
  DOLU: 'DOLU',
  TEMIZLIK: 'TEMIZLIK',
  BAKIM: 'BAKIM'
};

export type OdaDurumTipi = (typeof OdaDurumTipi)[keyof typeof OdaDurumTipi]

}

export type Rol = $Enums.Rol

export const Rol: typeof $Enums.Rol

export type RezervasyonDurumu = $Enums.RezervasyonDurumu

export const RezervasyonDurumu: typeof $Enums.RezervasyonDurumu

export type OdaDurumTipi = $Enums.OdaDurumTipi

export const OdaDurumTipi: typeof $Enums.OdaDurumTipi

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Musteris
 * const musteris = await prisma.musteri.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Musteris
   * const musteris = await prisma.musteri.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.musteri`: Exposes CRUD operations for the **Musteri** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Musteris
    * const musteris = await prisma.musteri.findMany()
    * ```
    */
  get musteri(): Prisma.MusteriDelegate<ExtArgs>;

  /**
   * `prisma.otel`: Exposes CRUD operations for the **Otel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Otels
    * const otels = await prisma.otel.findMany()
    * ```
    */
  get otel(): Prisma.OtelDelegate<ExtArgs>;

  /**
   * `prisma.oda`: Exposes CRUD operations for the **Oda** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Odas
    * const odas = await prisma.oda.findMany()
    * ```
    */
  get oda(): Prisma.OdaDelegate<ExtArgs>;

  /**
   * `prisma.rezervasyon`: Exposes CRUD operations for the **Rezervasyon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rezervasyons
    * const rezervasyons = await prisma.rezervasyon.findMany()
    * ```
    */
  get rezervasyon(): Prisma.RezervasyonDelegate<ExtArgs>;

  /**
   * `prisma.odaDurumu`: Exposes CRUD operations for the **OdaDurumu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OdaDurumus
    * const odaDurumus = await prisma.odaDurumu.findMany()
    * ```
    */
  get odaDurumu(): Prisma.OdaDurumuDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Musteri: 'Musteri',
    Otel: 'Otel',
    Oda: 'Oda',
    Rezervasyon: 'Rezervasyon',
    OdaDurumu: 'OdaDurumu'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "musteri" | "otel" | "oda" | "rezervasyon" | "odaDurumu"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Musteri: {
        payload: Prisma.$MusteriPayload<ExtArgs>
        fields: Prisma.MusteriFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MusteriFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusteriPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MusteriFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusteriPayload>
          }
          findFirst: {
            args: Prisma.MusteriFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusteriPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MusteriFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusteriPayload>
          }
          findMany: {
            args: Prisma.MusteriFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusteriPayload>[]
          }
          create: {
            args: Prisma.MusteriCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusteriPayload>
          }
          createMany: {
            args: Prisma.MusteriCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MusteriCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusteriPayload>[]
          }
          delete: {
            args: Prisma.MusteriDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusteriPayload>
          }
          update: {
            args: Prisma.MusteriUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusteriPayload>
          }
          deleteMany: {
            args: Prisma.MusteriDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MusteriUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MusteriUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusteriPayload>
          }
          aggregate: {
            args: Prisma.MusteriAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMusteri>
          }
          groupBy: {
            args: Prisma.MusteriGroupByArgs<ExtArgs>
            result: $Utils.Optional<MusteriGroupByOutputType>[]
          }
          count: {
            args: Prisma.MusteriCountArgs<ExtArgs>
            result: $Utils.Optional<MusteriCountAggregateOutputType> | number
          }
        }
      }
      Otel: {
        payload: Prisma.$OtelPayload<ExtArgs>
        fields: Prisma.OtelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OtelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OtelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtelPayload>
          }
          findFirst: {
            args: Prisma.OtelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OtelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtelPayload>
          }
          findMany: {
            args: Prisma.OtelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtelPayload>[]
          }
          create: {
            args: Prisma.OtelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtelPayload>
          }
          createMany: {
            args: Prisma.OtelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OtelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtelPayload>[]
          }
          delete: {
            args: Prisma.OtelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtelPayload>
          }
          update: {
            args: Prisma.OtelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtelPayload>
          }
          deleteMany: {
            args: Prisma.OtelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OtelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OtelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtelPayload>
          }
          aggregate: {
            args: Prisma.OtelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOtel>
          }
          groupBy: {
            args: Prisma.OtelGroupByArgs<ExtArgs>
            result: $Utils.Optional<OtelGroupByOutputType>[]
          }
          count: {
            args: Prisma.OtelCountArgs<ExtArgs>
            result: $Utils.Optional<OtelCountAggregateOutputType> | number
          }
        }
      }
      Oda: {
        payload: Prisma.$OdaPayload<ExtArgs>
        fields: Prisma.OdaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OdaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OdaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OdaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OdaPayload>
          }
          findFirst: {
            args: Prisma.OdaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OdaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OdaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OdaPayload>
          }
          findMany: {
            args: Prisma.OdaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OdaPayload>[]
          }
          create: {
            args: Prisma.OdaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OdaPayload>
          }
          createMany: {
            args: Prisma.OdaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OdaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OdaPayload>[]
          }
          delete: {
            args: Prisma.OdaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OdaPayload>
          }
          update: {
            args: Prisma.OdaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OdaPayload>
          }
          deleteMany: {
            args: Prisma.OdaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OdaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OdaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OdaPayload>
          }
          aggregate: {
            args: Prisma.OdaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOda>
          }
          groupBy: {
            args: Prisma.OdaGroupByArgs<ExtArgs>
            result: $Utils.Optional<OdaGroupByOutputType>[]
          }
          count: {
            args: Prisma.OdaCountArgs<ExtArgs>
            result: $Utils.Optional<OdaCountAggregateOutputType> | number
          }
        }
      }
      Rezervasyon: {
        payload: Prisma.$RezervasyonPayload<ExtArgs>
        fields: Prisma.RezervasyonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RezervasyonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RezervasyonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RezervasyonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RezervasyonPayload>
          }
          findFirst: {
            args: Prisma.RezervasyonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RezervasyonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RezervasyonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RezervasyonPayload>
          }
          findMany: {
            args: Prisma.RezervasyonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RezervasyonPayload>[]
          }
          create: {
            args: Prisma.RezervasyonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RezervasyonPayload>
          }
          createMany: {
            args: Prisma.RezervasyonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RezervasyonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RezervasyonPayload>[]
          }
          delete: {
            args: Prisma.RezervasyonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RezervasyonPayload>
          }
          update: {
            args: Prisma.RezervasyonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RezervasyonPayload>
          }
          deleteMany: {
            args: Prisma.RezervasyonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RezervasyonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RezervasyonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RezervasyonPayload>
          }
          aggregate: {
            args: Prisma.RezervasyonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRezervasyon>
          }
          groupBy: {
            args: Prisma.RezervasyonGroupByArgs<ExtArgs>
            result: $Utils.Optional<RezervasyonGroupByOutputType>[]
          }
          count: {
            args: Prisma.RezervasyonCountArgs<ExtArgs>
            result: $Utils.Optional<RezervasyonCountAggregateOutputType> | number
          }
        }
      }
      OdaDurumu: {
        payload: Prisma.$OdaDurumuPayload<ExtArgs>
        fields: Prisma.OdaDurumuFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OdaDurumuFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OdaDurumuPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OdaDurumuFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OdaDurumuPayload>
          }
          findFirst: {
            args: Prisma.OdaDurumuFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OdaDurumuPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OdaDurumuFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OdaDurumuPayload>
          }
          findMany: {
            args: Prisma.OdaDurumuFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OdaDurumuPayload>[]
          }
          create: {
            args: Prisma.OdaDurumuCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OdaDurumuPayload>
          }
          createMany: {
            args: Prisma.OdaDurumuCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OdaDurumuCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OdaDurumuPayload>[]
          }
          delete: {
            args: Prisma.OdaDurumuDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OdaDurumuPayload>
          }
          update: {
            args: Prisma.OdaDurumuUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OdaDurumuPayload>
          }
          deleteMany: {
            args: Prisma.OdaDurumuDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OdaDurumuUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OdaDurumuUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OdaDurumuPayload>
          }
          aggregate: {
            args: Prisma.OdaDurumuAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOdaDurumu>
          }
          groupBy: {
            args: Prisma.OdaDurumuGroupByArgs<ExtArgs>
            result: $Utils.Optional<OdaDurumuGroupByOutputType>[]
          }
          count: {
            args: Prisma.OdaDurumuCountArgs<ExtArgs>
            result: $Utils.Optional<OdaDurumuCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type MusteriCountOutputType
   */

  export type MusteriCountOutputType = {
    rezervasyonlar: number
    yoneticiOlduguOteller: number
  }

  export type MusteriCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rezervasyonlar?: boolean | MusteriCountOutputTypeCountRezervasyonlarArgs
    yoneticiOlduguOteller?: boolean | MusteriCountOutputTypeCountYoneticiOlduguOtellerArgs
  }

  // Custom InputTypes
  /**
   * MusteriCountOutputType without action
   */
  export type MusteriCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MusteriCountOutputType
     */
    select?: MusteriCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MusteriCountOutputType without action
   */
  export type MusteriCountOutputTypeCountRezervasyonlarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RezervasyonWhereInput
  }

  /**
   * MusteriCountOutputType without action
   */
  export type MusteriCountOutputTypeCountYoneticiOlduguOtellerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtelWhereInput
  }


  /**
   * Count Type OtelCountOutputType
   */

  export type OtelCountOutputType = {
    odalar: number
  }

  export type OtelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    odalar?: boolean | OtelCountOutputTypeCountOdalarArgs
  }

  // Custom InputTypes
  /**
   * OtelCountOutputType without action
   */
  export type OtelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtelCountOutputType
     */
    select?: OtelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OtelCountOutputType without action
   */
  export type OtelCountOutputTypeCountOdalarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OdaWhereInput
  }


  /**
   * Count Type OdaCountOutputType
   */

  export type OdaCountOutputType = {
    rezervasyonlar: number
    durumlar: number
  }

  export type OdaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rezervasyonlar?: boolean | OdaCountOutputTypeCountRezervasyonlarArgs
    durumlar?: boolean | OdaCountOutputTypeCountDurumlarArgs
  }

  // Custom InputTypes
  /**
   * OdaCountOutputType without action
   */
  export type OdaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OdaCountOutputType
     */
    select?: OdaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OdaCountOutputType without action
   */
  export type OdaCountOutputTypeCountRezervasyonlarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RezervasyonWhereInput
  }

  /**
   * OdaCountOutputType without action
   */
  export type OdaCountOutputTypeCountDurumlarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OdaDurumuWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Musteri
   */

  export type AggregateMusteri = {
    _count: MusteriCountAggregateOutputType | null
    _avg: MusteriAvgAggregateOutputType | null
    _sum: MusteriSumAggregateOutputType | null
    _min: MusteriMinAggregateOutputType | null
    _max: MusteriMaxAggregateOutputType | null
  }

  export type MusteriAvgAggregateOutputType = {
    id: number | null
  }

  export type MusteriSumAggregateOutputType = {
    id: number | null
  }

  export type MusteriMinAggregateOutputType = {
    id: number | null
    ad: string | null
    soyad: string | null
    email: string | null
    telefon: string | null
    sifre: string | null
    rol: $Enums.Rol | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MusteriMaxAggregateOutputType = {
    id: number | null
    ad: string | null
    soyad: string | null
    email: string | null
    telefon: string | null
    sifre: string | null
    rol: $Enums.Rol | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MusteriCountAggregateOutputType = {
    id: number
    ad: number
    soyad: number
    email: number
    telefon: number
    sifre: number
    rol: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MusteriAvgAggregateInputType = {
    id?: true
  }

  export type MusteriSumAggregateInputType = {
    id?: true
  }

  export type MusteriMinAggregateInputType = {
    id?: true
    ad?: true
    soyad?: true
    email?: true
    telefon?: true
    sifre?: true
    rol?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MusteriMaxAggregateInputType = {
    id?: true
    ad?: true
    soyad?: true
    email?: true
    telefon?: true
    sifre?: true
    rol?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MusteriCountAggregateInputType = {
    id?: true
    ad?: true
    soyad?: true
    email?: true
    telefon?: true
    sifre?: true
    rol?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MusteriAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Musteri to aggregate.
     */
    where?: MusteriWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Musteris to fetch.
     */
    orderBy?: MusteriOrderByWithRelationInput | MusteriOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MusteriWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Musteris from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Musteris.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Musteris
    **/
    _count?: true | MusteriCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MusteriAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MusteriSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MusteriMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MusteriMaxAggregateInputType
  }

  export type GetMusteriAggregateType<T extends MusteriAggregateArgs> = {
        [P in keyof T & keyof AggregateMusteri]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMusteri[P]>
      : GetScalarType<T[P], AggregateMusteri[P]>
  }




  export type MusteriGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MusteriWhereInput
    orderBy?: MusteriOrderByWithAggregationInput | MusteriOrderByWithAggregationInput[]
    by: MusteriScalarFieldEnum[] | MusteriScalarFieldEnum
    having?: MusteriScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MusteriCountAggregateInputType | true
    _avg?: MusteriAvgAggregateInputType
    _sum?: MusteriSumAggregateInputType
    _min?: MusteriMinAggregateInputType
    _max?: MusteriMaxAggregateInputType
  }

  export type MusteriGroupByOutputType = {
    id: number
    ad: string
    soyad: string
    email: string
    telefon: string
    sifre: string
    rol: $Enums.Rol
    createdAt: Date
    updatedAt: Date
    _count: MusteriCountAggregateOutputType | null
    _avg: MusteriAvgAggregateOutputType | null
    _sum: MusteriSumAggregateOutputType | null
    _min: MusteriMinAggregateOutputType | null
    _max: MusteriMaxAggregateOutputType | null
  }

  type GetMusteriGroupByPayload<T extends MusteriGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MusteriGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MusteriGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MusteriGroupByOutputType[P]>
            : GetScalarType<T[P], MusteriGroupByOutputType[P]>
        }
      >
    >


  export type MusteriSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ad?: boolean
    soyad?: boolean
    email?: boolean
    telefon?: boolean
    sifre?: boolean
    rol?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rezervasyonlar?: boolean | Musteri$rezervasyonlarArgs<ExtArgs>
    yoneticiOlduguOteller?: boolean | Musteri$yoneticiOlduguOtellerArgs<ExtArgs>
    _count?: boolean | MusteriCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["musteri"]>

  export type MusteriSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ad?: boolean
    soyad?: boolean
    email?: boolean
    telefon?: boolean
    sifre?: boolean
    rol?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["musteri"]>

  export type MusteriSelectScalar = {
    id?: boolean
    ad?: boolean
    soyad?: boolean
    email?: boolean
    telefon?: boolean
    sifre?: boolean
    rol?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MusteriInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rezervasyonlar?: boolean | Musteri$rezervasyonlarArgs<ExtArgs>
    yoneticiOlduguOteller?: boolean | Musteri$yoneticiOlduguOtellerArgs<ExtArgs>
    _count?: boolean | MusteriCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MusteriIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MusteriPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Musteri"
    objects: {
      rezervasyonlar: Prisma.$RezervasyonPayload<ExtArgs>[]
      yoneticiOlduguOteller: Prisma.$OtelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ad: string
      soyad: string
      email: string
      telefon: string
      sifre: string
      rol: $Enums.Rol
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["musteri"]>
    composites: {}
  }

  type MusteriGetPayload<S extends boolean | null | undefined | MusteriDefaultArgs> = $Result.GetResult<Prisma.$MusteriPayload, S>

  type MusteriCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MusteriFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MusteriCountAggregateInputType | true
    }

  export interface MusteriDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Musteri'], meta: { name: 'Musteri' } }
    /**
     * Find zero or one Musteri that matches the filter.
     * @param {MusteriFindUniqueArgs} args - Arguments to find a Musteri
     * @example
     * // Get one Musteri
     * const musteri = await prisma.musteri.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MusteriFindUniqueArgs>(args: SelectSubset<T, MusteriFindUniqueArgs<ExtArgs>>): Prisma__MusteriClient<$Result.GetResult<Prisma.$MusteriPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Musteri that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MusteriFindUniqueOrThrowArgs} args - Arguments to find a Musteri
     * @example
     * // Get one Musteri
     * const musteri = await prisma.musteri.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MusteriFindUniqueOrThrowArgs>(args: SelectSubset<T, MusteriFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MusteriClient<$Result.GetResult<Prisma.$MusteriPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Musteri that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MusteriFindFirstArgs} args - Arguments to find a Musteri
     * @example
     * // Get one Musteri
     * const musteri = await prisma.musteri.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MusteriFindFirstArgs>(args?: SelectSubset<T, MusteriFindFirstArgs<ExtArgs>>): Prisma__MusteriClient<$Result.GetResult<Prisma.$MusteriPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Musteri that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MusteriFindFirstOrThrowArgs} args - Arguments to find a Musteri
     * @example
     * // Get one Musteri
     * const musteri = await prisma.musteri.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MusteriFindFirstOrThrowArgs>(args?: SelectSubset<T, MusteriFindFirstOrThrowArgs<ExtArgs>>): Prisma__MusteriClient<$Result.GetResult<Prisma.$MusteriPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Musteris that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MusteriFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Musteris
     * const musteris = await prisma.musteri.findMany()
     * 
     * // Get first 10 Musteris
     * const musteris = await prisma.musteri.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const musteriWithIdOnly = await prisma.musteri.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MusteriFindManyArgs>(args?: SelectSubset<T, MusteriFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MusteriPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Musteri.
     * @param {MusteriCreateArgs} args - Arguments to create a Musteri.
     * @example
     * // Create one Musteri
     * const Musteri = await prisma.musteri.create({
     *   data: {
     *     // ... data to create a Musteri
     *   }
     * })
     * 
     */
    create<T extends MusteriCreateArgs>(args: SelectSubset<T, MusteriCreateArgs<ExtArgs>>): Prisma__MusteriClient<$Result.GetResult<Prisma.$MusteriPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Musteris.
     * @param {MusteriCreateManyArgs} args - Arguments to create many Musteris.
     * @example
     * // Create many Musteris
     * const musteri = await prisma.musteri.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MusteriCreateManyArgs>(args?: SelectSubset<T, MusteriCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Musteris and returns the data saved in the database.
     * @param {MusteriCreateManyAndReturnArgs} args - Arguments to create many Musteris.
     * @example
     * // Create many Musteris
     * const musteri = await prisma.musteri.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Musteris and only return the `id`
     * const musteriWithIdOnly = await prisma.musteri.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MusteriCreateManyAndReturnArgs>(args?: SelectSubset<T, MusteriCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MusteriPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Musteri.
     * @param {MusteriDeleteArgs} args - Arguments to delete one Musteri.
     * @example
     * // Delete one Musteri
     * const Musteri = await prisma.musteri.delete({
     *   where: {
     *     // ... filter to delete one Musteri
     *   }
     * })
     * 
     */
    delete<T extends MusteriDeleteArgs>(args: SelectSubset<T, MusteriDeleteArgs<ExtArgs>>): Prisma__MusteriClient<$Result.GetResult<Prisma.$MusteriPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Musteri.
     * @param {MusteriUpdateArgs} args - Arguments to update one Musteri.
     * @example
     * // Update one Musteri
     * const musteri = await prisma.musteri.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MusteriUpdateArgs>(args: SelectSubset<T, MusteriUpdateArgs<ExtArgs>>): Prisma__MusteriClient<$Result.GetResult<Prisma.$MusteriPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Musteris.
     * @param {MusteriDeleteManyArgs} args - Arguments to filter Musteris to delete.
     * @example
     * // Delete a few Musteris
     * const { count } = await prisma.musteri.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MusteriDeleteManyArgs>(args?: SelectSubset<T, MusteriDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Musteris.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MusteriUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Musteris
     * const musteri = await prisma.musteri.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MusteriUpdateManyArgs>(args: SelectSubset<T, MusteriUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Musteri.
     * @param {MusteriUpsertArgs} args - Arguments to update or create a Musteri.
     * @example
     * // Update or create a Musteri
     * const musteri = await prisma.musteri.upsert({
     *   create: {
     *     // ... data to create a Musteri
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Musteri we want to update
     *   }
     * })
     */
    upsert<T extends MusteriUpsertArgs>(args: SelectSubset<T, MusteriUpsertArgs<ExtArgs>>): Prisma__MusteriClient<$Result.GetResult<Prisma.$MusteriPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Musteris.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MusteriCountArgs} args - Arguments to filter Musteris to count.
     * @example
     * // Count the number of Musteris
     * const count = await prisma.musteri.count({
     *   where: {
     *     // ... the filter for the Musteris we want to count
     *   }
     * })
    **/
    count<T extends MusteriCountArgs>(
      args?: Subset<T, MusteriCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MusteriCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Musteri.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MusteriAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MusteriAggregateArgs>(args: Subset<T, MusteriAggregateArgs>): Prisma.PrismaPromise<GetMusteriAggregateType<T>>

    /**
     * Group by Musteri.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MusteriGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MusteriGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MusteriGroupByArgs['orderBy'] }
        : { orderBy?: MusteriGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MusteriGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMusteriGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Musteri model
   */
  readonly fields: MusteriFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Musteri.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MusteriClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rezervasyonlar<T extends Musteri$rezervasyonlarArgs<ExtArgs> = {}>(args?: Subset<T, Musteri$rezervasyonlarArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RezervasyonPayload<ExtArgs>, T, "findMany"> | Null>
    yoneticiOlduguOteller<T extends Musteri$yoneticiOlduguOtellerArgs<ExtArgs> = {}>(args?: Subset<T, Musteri$yoneticiOlduguOtellerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtelPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Musteri model
   */ 
  interface MusteriFieldRefs {
    readonly id: FieldRef<"Musteri", 'Int'>
    readonly ad: FieldRef<"Musteri", 'String'>
    readonly soyad: FieldRef<"Musteri", 'String'>
    readonly email: FieldRef<"Musteri", 'String'>
    readonly telefon: FieldRef<"Musteri", 'String'>
    readonly sifre: FieldRef<"Musteri", 'String'>
    readonly rol: FieldRef<"Musteri", 'Rol'>
    readonly createdAt: FieldRef<"Musteri", 'DateTime'>
    readonly updatedAt: FieldRef<"Musteri", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Musteri findUnique
   */
  export type MusteriFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Musteri
     */
    select?: MusteriSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusteriInclude<ExtArgs> | null
    /**
     * Filter, which Musteri to fetch.
     */
    where: MusteriWhereUniqueInput
  }

  /**
   * Musteri findUniqueOrThrow
   */
  export type MusteriFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Musteri
     */
    select?: MusteriSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusteriInclude<ExtArgs> | null
    /**
     * Filter, which Musteri to fetch.
     */
    where: MusteriWhereUniqueInput
  }

  /**
   * Musteri findFirst
   */
  export type MusteriFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Musteri
     */
    select?: MusteriSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusteriInclude<ExtArgs> | null
    /**
     * Filter, which Musteri to fetch.
     */
    where?: MusteriWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Musteris to fetch.
     */
    orderBy?: MusteriOrderByWithRelationInput | MusteriOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Musteris.
     */
    cursor?: MusteriWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Musteris from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Musteris.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Musteris.
     */
    distinct?: MusteriScalarFieldEnum | MusteriScalarFieldEnum[]
  }

  /**
   * Musteri findFirstOrThrow
   */
  export type MusteriFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Musteri
     */
    select?: MusteriSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusteriInclude<ExtArgs> | null
    /**
     * Filter, which Musteri to fetch.
     */
    where?: MusteriWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Musteris to fetch.
     */
    orderBy?: MusteriOrderByWithRelationInput | MusteriOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Musteris.
     */
    cursor?: MusteriWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Musteris from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Musteris.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Musteris.
     */
    distinct?: MusteriScalarFieldEnum | MusteriScalarFieldEnum[]
  }

  /**
   * Musteri findMany
   */
  export type MusteriFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Musteri
     */
    select?: MusteriSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusteriInclude<ExtArgs> | null
    /**
     * Filter, which Musteris to fetch.
     */
    where?: MusteriWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Musteris to fetch.
     */
    orderBy?: MusteriOrderByWithRelationInput | MusteriOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Musteris.
     */
    cursor?: MusteriWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Musteris from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Musteris.
     */
    skip?: number
    distinct?: MusteriScalarFieldEnum | MusteriScalarFieldEnum[]
  }

  /**
   * Musteri create
   */
  export type MusteriCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Musteri
     */
    select?: MusteriSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusteriInclude<ExtArgs> | null
    /**
     * The data needed to create a Musteri.
     */
    data: XOR<MusteriCreateInput, MusteriUncheckedCreateInput>
  }

  /**
   * Musteri createMany
   */
  export type MusteriCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Musteris.
     */
    data: MusteriCreateManyInput | MusteriCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Musteri createManyAndReturn
   */
  export type MusteriCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Musteri
     */
    select?: MusteriSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Musteris.
     */
    data: MusteriCreateManyInput | MusteriCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Musteri update
   */
  export type MusteriUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Musteri
     */
    select?: MusteriSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusteriInclude<ExtArgs> | null
    /**
     * The data needed to update a Musteri.
     */
    data: XOR<MusteriUpdateInput, MusteriUncheckedUpdateInput>
    /**
     * Choose, which Musteri to update.
     */
    where: MusteriWhereUniqueInput
  }

  /**
   * Musteri updateMany
   */
  export type MusteriUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Musteris.
     */
    data: XOR<MusteriUpdateManyMutationInput, MusteriUncheckedUpdateManyInput>
    /**
     * Filter which Musteris to update
     */
    where?: MusteriWhereInput
  }

  /**
   * Musteri upsert
   */
  export type MusteriUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Musteri
     */
    select?: MusteriSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusteriInclude<ExtArgs> | null
    /**
     * The filter to search for the Musteri to update in case it exists.
     */
    where: MusteriWhereUniqueInput
    /**
     * In case the Musteri found by the `where` argument doesn't exist, create a new Musteri with this data.
     */
    create: XOR<MusteriCreateInput, MusteriUncheckedCreateInput>
    /**
     * In case the Musteri was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MusteriUpdateInput, MusteriUncheckedUpdateInput>
  }

  /**
   * Musteri delete
   */
  export type MusteriDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Musteri
     */
    select?: MusteriSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusteriInclude<ExtArgs> | null
    /**
     * Filter which Musteri to delete.
     */
    where: MusteriWhereUniqueInput
  }

  /**
   * Musteri deleteMany
   */
  export type MusteriDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Musteris to delete
     */
    where?: MusteriWhereInput
  }

  /**
   * Musteri.rezervasyonlar
   */
  export type Musteri$rezervasyonlarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rezervasyon
     */
    select?: RezervasyonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RezervasyonInclude<ExtArgs> | null
    where?: RezervasyonWhereInput
    orderBy?: RezervasyonOrderByWithRelationInput | RezervasyonOrderByWithRelationInput[]
    cursor?: RezervasyonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RezervasyonScalarFieldEnum | RezervasyonScalarFieldEnum[]
  }

  /**
   * Musteri.yoneticiOlduguOteller
   */
  export type Musteri$yoneticiOlduguOtellerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otel
     */
    select?: OtelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtelInclude<ExtArgs> | null
    where?: OtelWhereInput
    orderBy?: OtelOrderByWithRelationInput | OtelOrderByWithRelationInput[]
    cursor?: OtelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OtelScalarFieldEnum | OtelScalarFieldEnum[]
  }

  /**
   * Musteri without action
   */
  export type MusteriDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Musteri
     */
    select?: MusteriSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusteriInclude<ExtArgs> | null
  }


  /**
   * Model Otel
   */

  export type AggregateOtel = {
    _count: OtelCountAggregateOutputType | null
    _avg: OtelAvgAggregateOutputType | null
    _sum: OtelSumAggregateOutputType | null
    _min: OtelMinAggregateOutputType | null
    _max: OtelMaxAggregateOutputType | null
  }

  export type OtelAvgAggregateOutputType = {
    id: number | null
    yildiz: number | null
    yoneticiId: number | null
  }

  export type OtelSumAggregateOutputType = {
    id: number | null
    yildiz: number | null
    yoneticiId: number | null
  }

  export type OtelMinAggregateOutputType = {
    id: number | null
    ad: string | null
    adres: string | null
    sehir: string | null
    yildiz: number | null
    aciklama: string | null
    yoneticiId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OtelMaxAggregateOutputType = {
    id: number | null
    ad: string | null
    adres: string | null
    sehir: string | null
    yildiz: number | null
    aciklama: string | null
    yoneticiId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OtelCountAggregateOutputType = {
    id: number
    ad: number
    adres: number
    sehir: number
    yildiz: number
    aciklama: number
    yoneticiId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OtelAvgAggregateInputType = {
    id?: true
    yildiz?: true
    yoneticiId?: true
  }

  export type OtelSumAggregateInputType = {
    id?: true
    yildiz?: true
    yoneticiId?: true
  }

  export type OtelMinAggregateInputType = {
    id?: true
    ad?: true
    adres?: true
    sehir?: true
    yildiz?: true
    aciklama?: true
    yoneticiId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OtelMaxAggregateInputType = {
    id?: true
    ad?: true
    adres?: true
    sehir?: true
    yildiz?: true
    aciklama?: true
    yoneticiId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OtelCountAggregateInputType = {
    id?: true
    ad?: true
    adres?: true
    sehir?: true
    yildiz?: true
    aciklama?: true
    yoneticiId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OtelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Otel to aggregate.
     */
    where?: OtelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otels to fetch.
     */
    orderBy?: OtelOrderByWithRelationInput | OtelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OtelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Otels
    **/
    _count?: true | OtelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OtelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OtelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OtelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OtelMaxAggregateInputType
  }

  export type GetOtelAggregateType<T extends OtelAggregateArgs> = {
        [P in keyof T & keyof AggregateOtel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOtel[P]>
      : GetScalarType<T[P], AggregateOtel[P]>
  }




  export type OtelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtelWhereInput
    orderBy?: OtelOrderByWithAggregationInput | OtelOrderByWithAggregationInput[]
    by: OtelScalarFieldEnum[] | OtelScalarFieldEnum
    having?: OtelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OtelCountAggregateInputType | true
    _avg?: OtelAvgAggregateInputType
    _sum?: OtelSumAggregateInputType
    _min?: OtelMinAggregateInputType
    _max?: OtelMaxAggregateInputType
  }

  export type OtelGroupByOutputType = {
    id: number
    ad: string
    adres: string
    sehir: string
    yildiz: number
    aciklama: string | null
    yoneticiId: number
    createdAt: Date
    updatedAt: Date
    _count: OtelCountAggregateOutputType | null
    _avg: OtelAvgAggregateOutputType | null
    _sum: OtelSumAggregateOutputType | null
    _min: OtelMinAggregateOutputType | null
    _max: OtelMaxAggregateOutputType | null
  }

  type GetOtelGroupByPayload<T extends OtelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OtelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OtelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OtelGroupByOutputType[P]>
            : GetScalarType<T[P], OtelGroupByOutputType[P]>
        }
      >
    >


  export type OtelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ad?: boolean
    adres?: boolean
    sehir?: boolean
    yildiz?: boolean
    aciklama?: boolean
    yoneticiId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    yonetici?: boolean | MusteriDefaultArgs<ExtArgs>
    odalar?: boolean | Otel$odalarArgs<ExtArgs>
    _count?: boolean | OtelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["otel"]>

  export type OtelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ad?: boolean
    adres?: boolean
    sehir?: boolean
    yildiz?: boolean
    aciklama?: boolean
    yoneticiId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    yonetici?: boolean | MusteriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["otel"]>

  export type OtelSelectScalar = {
    id?: boolean
    ad?: boolean
    adres?: boolean
    sehir?: boolean
    yildiz?: boolean
    aciklama?: boolean
    yoneticiId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OtelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    yonetici?: boolean | MusteriDefaultArgs<ExtArgs>
    odalar?: boolean | Otel$odalarArgs<ExtArgs>
    _count?: boolean | OtelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OtelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    yonetici?: boolean | MusteriDefaultArgs<ExtArgs>
  }

  export type $OtelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Otel"
    objects: {
      yonetici: Prisma.$MusteriPayload<ExtArgs>
      odalar: Prisma.$OdaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ad: string
      adres: string
      sehir: string
      yildiz: number
      aciklama: string | null
      yoneticiId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["otel"]>
    composites: {}
  }

  type OtelGetPayload<S extends boolean | null | undefined | OtelDefaultArgs> = $Result.GetResult<Prisma.$OtelPayload, S>

  type OtelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OtelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OtelCountAggregateInputType | true
    }

  export interface OtelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Otel'], meta: { name: 'Otel' } }
    /**
     * Find zero or one Otel that matches the filter.
     * @param {OtelFindUniqueArgs} args - Arguments to find a Otel
     * @example
     * // Get one Otel
     * const otel = await prisma.otel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OtelFindUniqueArgs>(args: SelectSubset<T, OtelFindUniqueArgs<ExtArgs>>): Prisma__OtelClient<$Result.GetResult<Prisma.$OtelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Otel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OtelFindUniqueOrThrowArgs} args - Arguments to find a Otel
     * @example
     * // Get one Otel
     * const otel = await prisma.otel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OtelFindUniqueOrThrowArgs>(args: SelectSubset<T, OtelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OtelClient<$Result.GetResult<Prisma.$OtelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Otel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtelFindFirstArgs} args - Arguments to find a Otel
     * @example
     * // Get one Otel
     * const otel = await prisma.otel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OtelFindFirstArgs>(args?: SelectSubset<T, OtelFindFirstArgs<ExtArgs>>): Prisma__OtelClient<$Result.GetResult<Prisma.$OtelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Otel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtelFindFirstOrThrowArgs} args - Arguments to find a Otel
     * @example
     * // Get one Otel
     * const otel = await prisma.otel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OtelFindFirstOrThrowArgs>(args?: SelectSubset<T, OtelFindFirstOrThrowArgs<ExtArgs>>): Prisma__OtelClient<$Result.GetResult<Prisma.$OtelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Otels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Otels
     * const otels = await prisma.otel.findMany()
     * 
     * // Get first 10 Otels
     * const otels = await prisma.otel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const otelWithIdOnly = await prisma.otel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OtelFindManyArgs>(args?: SelectSubset<T, OtelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Otel.
     * @param {OtelCreateArgs} args - Arguments to create a Otel.
     * @example
     * // Create one Otel
     * const Otel = await prisma.otel.create({
     *   data: {
     *     // ... data to create a Otel
     *   }
     * })
     * 
     */
    create<T extends OtelCreateArgs>(args: SelectSubset<T, OtelCreateArgs<ExtArgs>>): Prisma__OtelClient<$Result.GetResult<Prisma.$OtelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Otels.
     * @param {OtelCreateManyArgs} args - Arguments to create many Otels.
     * @example
     * // Create many Otels
     * const otel = await prisma.otel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OtelCreateManyArgs>(args?: SelectSubset<T, OtelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Otels and returns the data saved in the database.
     * @param {OtelCreateManyAndReturnArgs} args - Arguments to create many Otels.
     * @example
     * // Create many Otels
     * const otel = await prisma.otel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Otels and only return the `id`
     * const otelWithIdOnly = await prisma.otel.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OtelCreateManyAndReturnArgs>(args?: SelectSubset<T, OtelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Otel.
     * @param {OtelDeleteArgs} args - Arguments to delete one Otel.
     * @example
     * // Delete one Otel
     * const Otel = await prisma.otel.delete({
     *   where: {
     *     // ... filter to delete one Otel
     *   }
     * })
     * 
     */
    delete<T extends OtelDeleteArgs>(args: SelectSubset<T, OtelDeleteArgs<ExtArgs>>): Prisma__OtelClient<$Result.GetResult<Prisma.$OtelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Otel.
     * @param {OtelUpdateArgs} args - Arguments to update one Otel.
     * @example
     * // Update one Otel
     * const otel = await prisma.otel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OtelUpdateArgs>(args: SelectSubset<T, OtelUpdateArgs<ExtArgs>>): Prisma__OtelClient<$Result.GetResult<Prisma.$OtelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Otels.
     * @param {OtelDeleteManyArgs} args - Arguments to filter Otels to delete.
     * @example
     * // Delete a few Otels
     * const { count } = await prisma.otel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OtelDeleteManyArgs>(args?: SelectSubset<T, OtelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Otels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Otels
     * const otel = await prisma.otel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OtelUpdateManyArgs>(args: SelectSubset<T, OtelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Otel.
     * @param {OtelUpsertArgs} args - Arguments to update or create a Otel.
     * @example
     * // Update or create a Otel
     * const otel = await prisma.otel.upsert({
     *   create: {
     *     // ... data to create a Otel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Otel we want to update
     *   }
     * })
     */
    upsert<T extends OtelUpsertArgs>(args: SelectSubset<T, OtelUpsertArgs<ExtArgs>>): Prisma__OtelClient<$Result.GetResult<Prisma.$OtelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Otels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtelCountArgs} args - Arguments to filter Otels to count.
     * @example
     * // Count the number of Otels
     * const count = await prisma.otel.count({
     *   where: {
     *     // ... the filter for the Otels we want to count
     *   }
     * })
    **/
    count<T extends OtelCountArgs>(
      args?: Subset<T, OtelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OtelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Otel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OtelAggregateArgs>(args: Subset<T, OtelAggregateArgs>): Prisma.PrismaPromise<GetOtelAggregateType<T>>

    /**
     * Group by Otel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OtelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OtelGroupByArgs['orderBy'] }
        : { orderBy?: OtelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OtelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOtelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Otel model
   */
  readonly fields: OtelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Otel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OtelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    yonetici<T extends MusteriDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MusteriDefaultArgs<ExtArgs>>): Prisma__MusteriClient<$Result.GetResult<Prisma.$MusteriPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    odalar<T extends Otel$odalarArgs<ExtArgs> = {}>(args?: Subset<T, Otel$odalarArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OdaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Otel model
   */ 
  interface OtelFieldRefs {
    readonly id: FieldRef<"Otel", 'Int'>
    readonly ad: FieldRef<"Otel", 'String'>
    readonly adres: FieldRef<"Otel", 'String'>
    readonly sehir: FieldRef<"Otel", 'String'>
    readonly yildiz: FieldRef<"Otel", 'Int'>
    readonly aciklama: FieldRef<"Otel", 'String'>
    readonly yoneticiId: FieldRef<"Otel", 'Int'>
    readonly createdAt: FieldRef<"Otel", 'DateTime'>
    readonly updatedAt: FieldRef<"Otel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Otel findUnique
   */
  export type OtelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otel
     */
    select?: OtelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtelInclude<ExtArgs> | null
    /**
     * Filter, which Otel to fetch.
     */
    where: OtelWhereUniqueInput
  }

  /**
   * Otel findUniqueOrThrow
   */
  export type OtelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otel
     */
    select?: OtelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtelInclude<ExtArgs> | null
    /**
     * Filter, which Otel to fetch.
     */
    where: OtelWhereUniqueInput
  }

  /**
   * Otel findFirst
   */
  export type OtelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otel
     */
    select?: OtelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtelInclude<ExtArgs> | null
    /**
     * Filter, which Otel to fetch.
     */
    where?: OtelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otels to fetch.
     */
    orderBy?: OtelOrderByWithRelationInput | OtelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Otels.
     */
    cursor?: OtelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Otels.
     */
    distinct?: OtelScalarFieldEnum | OtelScalarFieldEnum[]
  }

  /**
   * Otel findFirstOrThrow
   */
  export type OtelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otel
     */
    select?: OtelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtelInclude<ExtArgs> | null
    /**
     * Filter, which Otel to fetch.
     */
    where?: OtelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otels to fetch.
     */
    orderBy?: OtelOrderByWithRelationInput | OtelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Otels.
     */
    cursor?: OtelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Otels.
     */
    distinct?: OtelScalarFieldEnum | OtelScalarFieldEnum[]
  }

  /**
   * Otel findMany
   */
  export type OtelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otel
     */
    select?: OtelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtelInclude<ExtArgs> | null
    /**
     * Filter, which Otels to fetch.
     */
    where?: OtelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otels to fetch.
     */
    orderBy?: OtelOrderByWithRelationInput | OtelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Otels.
     */
    cursor?: OtelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otels.
     */
    skip?: number
    distinct?: OtelScalarFieldEnum | OtelScalarFieldEnum[]
  }

  /**
   * Otel create
   */
  export type OtelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otel
     */
    select?: OtelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtelInclude<ExtArgs> | null
    /**
     * The data needed to create a Otel.
     */
    data: XOR<OtelCreateInput, OtelUncheckedCreateInput>
  }

  /**
   * Otel createMany
   */
  export type OtelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Otels.
     */
    data: OtelCreateManyInput | OtelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Otel createManyAndReturn
   */
  export type OtelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otel
     */
    select?: OtelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Otels.
     */
    data: OtelCreateManyInput | OtelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Otel update
   */
  export type OtelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otel
     */
    select?: OtelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtelInclude<ExtArgs> | null
    /**
     * The data needed to update a Otel.
     */
    data: XOR<OtelUpdateInput, OtelUncheckedUpdateInput>
    /**
     * Choose, which Otel to update.
     */
    where: OtelWhereUniqueInput
  }

  /**
   * Otel updateMany
   */
  export type OtelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Otels.
     */
    data: XOR<OtelUpdateManyMutationInput, OtelUncheckedUpdateManyInput>
    /**
     * Filter which Otels to update
     */
    where?: OtelWhereInput
  }

  /**
   * Otel upsert
   */
  export type OtelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otel
     */
    select?: OtelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtelInclude<ExtArgs> | null
    /**
     * The filter to search for the Otel to update in case it exists.
     */
    where: OtelWhereUniqueInput
    /**
     * In case the Otel found by the `where` argument doesn't exist, create a new Otel with this data.
     */
    create: XOR<OtelCreateInput, OtelUncheckedCreateInput>
    /**
     * In case the Otel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OtelUpdateInput, OtelUncheckedUpdateInput>
  }

  /**
   * Otel delete
   */
  export type OtelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otel
     */
    select?: OtelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtelInclude<ExtArgs> | null
    /**
     * Filter which Otel to delete.
     */
    where: OtelWhereUniqueInput
  }

  /**
   * Otel deleteMany
   */
  export type OtelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Otels to delete
     */
    where?: OtelWhereInput
  }

  /**
   * Otel.odalar
   */
  export type Otel$odalarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Oda
     */
    select?: OdaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OdaInclude<ExtArgs> | null
    where?: OdaWhereInput
    orderBy?: OdaOrderByWithRelationInput | OdaOrderByWithRelationInput[]
    cursor?: OdaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OdaScalarFieldEnum | OdaScalarFieldEnum[]
  }

  /**
   * Otel without action
   */
  export type OtelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otel
     */
    select?: OtelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtelInclude<ExtArgs> | null
  }


  /**
   * Model Oda
   */

  export type AggregateOda = {
    _count: OdaCountAggregateOutputType | null
    _avg: OdaAvgAggregateOutputType | null
    _sum: OdaSumAggregateOutputType | null
    _min: OdaMinAggregateOutputType | null
    _max: OdaMaxAggregateOutputType | null
  }

  export type OdaAvgAggregateOutputType = {
    id: number | null
    fiyat: number | null
    kapasite: number | null
    otelId: number | null
  }

  export type OdaSumAggregateOutputType = {
    id: number | null
    fiyat: number | null
    kapasite: number | null
    otelId: number | null
  }

  export type OdaMinAggregateOutputType = {
    id: number | null
    numara: string | null
    tip: string | null
    fiyat: number | null
    kapasite: number | null
    otelId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OdaMaxAggregateOutputType = {
    id: number | null
    numara: string | null
    tip: string | null
    fiyat: number | null
    kapasite: number | null
    otelId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OdaCountAggregateOutputType = {
    id: number
    numara: number
    tip: number
    fiyat: number
    kapasite: number
    otelId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OdaAvgAggregateInputType = {
    id?: true
    fiyat?: true
    kapasite?: true
    otelId?: true
  }

  export type OdaSumAggregateInputType = {
    id?: true
    fiyat?: true
    kapasite?: true
    otelId?: true
  }

  export type OdaMinAggregateInputType = {
    id?: true
    numara?: true
    tip?: true
    fiyat?: true
    kapasite?: true
    otelId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OdaMaxAggregateInputType = {
    id?: true
    numara?: true
    tip?: true
    fiyat?: true
    kapasite?: true
    otelId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OdaCountAggregateInputType = {
    id?: true
    numara?: true
    tip?: true
    fiyat?: true
    kapasite?: true
    otelId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OdaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Oda to aggregate.
     */
    where?: OdaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Odas to fetch.
     */
    orderBy?: OdaOrderByWithRelationInput | OdaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OdaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Odas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Odas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Odas
    **/
    _count?: true | OdaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OdaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OdaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OdaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OdaMaxAggregateInputType
  }

  export type GetOdaAggregateType<T extends OdaAggregateArgs> = {
        [P in keyof T & keyof AggregateOda]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOda[P]>
      : GetScalarType<T[P], AggregateOda[P]>
  }




  export type OdaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OdaWhereInput
    orderBy?: OdaOrderByWithAggregationInput | OdaOrderByWithAggregationInput[]
    by: OdaScalarFieldEnum[] | OdaScalarFieldEnum
    having?: OdaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OdaCountAggregateInputType | true
    _avg?: OdaAvgAggregateInputType
    _sum?: OdaSumAggregateInputType
    _min?: OdaMinAggregateInputType
    _max?: OdaMaxAggregateInputType
  }

  export type OdaGroupByOutputType = {
    id: number
    numara: string
    tip: string
    fiyat: number
    kapasite: number
    otelId: number
    createdAt: Date
    updatedAt: Date
    _count: OdaCountAggregateOutputType | null
    _avg: OdaAvgAggregateOutputType | null
    _sum: OdaSumAggregateOutputType | null
    _min: OdaMinAggregateOutputType | null
    _max: OdaMaxAggregateOutputType | null
  }

  type GetOdaGroupByPayload<T extends OdaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OdaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OdaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OdaGroupByOutputType[P]>
            : GetScalarType<T[P], OdaGroupByOutputType[P]>
        }
      >
    >


  export type OdaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numara?: boolean
    tip?: boolean
    fiyat?: boolean
    kapasite?: boolean
    otelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    otel?: boolean | OtelDefaultArgs<ExtArgs>
    rezervasyonlar?: boolean | Oda$rezervasyonlarArgs<ExtArgs>
    durumlar?: boolean | Oda$durumlarArgs<ExtArgs>
    _count?: boolean | OdaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oda"]>

  export type OdaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numara?: boolean
    tip?: boolean
    fiyat?: boolean
    kapasite?: boolean
    otelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    otel?: boolean | OtelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oda"]>

  export type OdaSelectScalar = {
    id?: boolean
    numara?: boolean
    tip?: boolean
    fiyat?: boolean
    kapasite?: boolean
    otelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OdaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    otel?: boolean | OtelDefaultArgs<ExtArgs>
    rezervasyonlar?: boolean | Oda$rezervasyonlarArgs<ExtArgs>
    durumlar?: boolean | Oda$durumlarArgs<ExtArgs>
    _count?: boolean | OdaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OdaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    otel?: boolean | OtelDefaultArgs<ExtArgs>
  }

  export type $OdaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Oda"
    objects: {
      otel: Prisma.$OtelPayload<ExtArgs>
      rezervasyonlar: Prisma.$RezervasyonPayload<ExtArgs>[]
      durumlar: Prisma.$OdaDurumuPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      numara: string
      tip: string
      fiyat: number
      kapasite: number
      otelId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["oda"]>
    composites: {}
  }

  type OdaGetPayload<S extends boolean | null | undefined | OdaDefaultArgs> = $Result.GetResult<Prisma.$OdaPayload, S>

  type OdaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OdaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OdaCountAggregateInputType | true
    }

  export interface OdaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Oda'], meta: { name: 'Oda' } }
    /**
     * Find zero or one Oda that matches the filter.
     * @param {OdaFindUniqueArgs} args - Arguments to find a Oda
     * @example
     * // Get one Oda
     * const oda = await prisma.oda.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OdaFindUniqueArgs>(args: SelectSubset<T, OdaFindUniqueArgs<ExtArgs>>): Prisma__OdaClient<$Result.GetResult<Prisma.$OdaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Oda that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OdaFindUniqueOrThrowArgs} args - Arguments to find a Oda
     * @example
     * // Get one Oda
     * const oda = await prisma.oda.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OdaFindUniqueOrThrowArgs>(args: SelectSubset<T, OdaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OdaClient<$Result.GetResult<Prisma.$OdaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Oda that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OdaFindFirstArgs} args - Arguments to find a Oda
     * @example
     * // Get one Oda
     * const oda = await prisma.oda.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OdaFindFirstArgs>(args?: SelectSubset<T, OdaFindFirstArgs<ExtArgs>>): Prisma__OdaClient<$Result.GetResult<Prisma.$OdaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Oda that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OdaFindFirstOrThrowArgs} args - Arguments to find a Oda
     * @example
     * // Get one Oda
     * const oda = await prisma.oda.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OdaFindFirstOrThrowArgs>(args?: SelectSubset<T, OdaFindFirstOrThrowArgs<ExtArgs>>): Prisma__OdaClient<$Result.GetResult<Prisma.$OdaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Odas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OdaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Odas
     * const odas = await prisma.oda.findMany()
     * 
     * // Get first 10 Odas
     * const odas = await prisma.oda.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const odaWithIdOnly = await prisma.oda.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OdaFindManyArgs>(args?: SelectSubset<T, OdaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OdaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Oda.
     * @param {OdaCreateArgs} args - Arguments to create a Oda.
     * @example
     * // Create one Oda
     * const Oda = await prisma.oda.create({
     *   data: {
     *     // ... data to create a Oda
     *   }
     * })
     * 
     */
    create<T extends OdaCreateArgs>(args: SelectSubset<T, OdaCreateArgs<ExtArgs>>): Prisma__OdaClient<$Result.GetResult<Prisma.$OdaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Odas.
     * @param {OdaCreateManyArgs} args - Arguments to create many Odas.
     * @example
     * // Create many Odas
     * const oda = await prisma.oda.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OdaCreateManyArgs>(args?: SelectSubset<T, OdaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Odas and returns the data saved in the database.
     * @param {OdaCreateManyAndReturnArgs} args - Arguments to create many Odas.
     * @example
     * // Create many Odas
     * const oda = await prisma.oda.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Odas and only return the `id`
     * const odaWithIdOnly = await prisma.oda.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OdaCreateManyAndReturnArgs>(args?: SelectSubset<T, OdaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OdaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Oda.
     * @param {OdaDeleteArgs} args - Arguments to delete one Oda.
     * @example
     * // Delete one Oda
     * const Oda = await prisma.oda.delete({
     *   where: {
     *     // ... filter to delete one Oda
     *   }
     * })
     * 
     */
    delete<T extends OdaDeleteArgs>(args: SelectSubset<T, OdaDeleteArgs<ExtArgs>>): Prisma__OdaClient<$Result.GetResult<Prisma.$OdaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Oda.
     * @param {OdaUpdateArgs} args - Arguments to update one Oda.
     * @example
     * // Update one Oda
     * const oda = await prisma.oda.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OdaUpdateArgs>(args: SelectSubset<T, OdaUpdateArgs<ExtArgs>>): Prisma__OdaClient<$Result.GetResult<Prisma.$OdaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Odas.
     * @param {OdaDeleteManyArgs} args - Arguments to filter Odas to delete.
     * @example
     * // Delete a few Odas
     * const { count } = await prisma.oda.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OdaDeleteManyArgs>(args?: SelectSubset<T, OdaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Odas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OdaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Odas
     * const oda = await prisma.oda.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OdaUpdateManyArgs>(args: SelectSubset<T, OdaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Oda.
     * @param {OdaUpsertArgs} args - Arguments to update or create a Oda.
     * @example
     * // Update or create a Oda
     * const oda = await prisma.oda.upsert({
     *   create: {
     *     // ... data to create a Oda
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Oda we want to update
     *   }
     * })
     */
    upsert<T extends OdaUpsertArgs>(args: SelectSubset<T, OdaUpsertArgs<ExtArgs>>): Prisma__OdaClient<$Result.GetResult<Prisma.$OdaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Odas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OdaCountArgs} args - Arguments to filter Odas to count.
     * @example
     * // Count the number of Odas
     * const count = await prisma.oda.count({
     *   where: {
     *     // ... the filter for the Odas we want to count
     *   }
     * })
    **/
    count<T extends OdaCountArgs>(
      args?: Subset<T, OdaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OdaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Oda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OdaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OdaAggregateArgs>(args: Subset<T, OdaAggregateArgs>): Prisma.PrismaPromise<GetOdaAggregateType<T>>

    /**
     * Group by Oda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OdaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OdaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OdaGroupByArgs['orderBy'] }
        : { orderBy?: OdaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OdaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOdaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Oda model
   */
  readonly fields: OdaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Oda.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OdaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    otel<T extends OtelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OtelDefaultArgs<ExtArgs>>): Prisma__OtelClient<$Result.GetResult<Prisma.$OtelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    rezervasyonlar<T extends Oda$rezervasyonlarArgs<ExtArgs> = {}>(args?: Subset<T, Oda$rezervasyonlarArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RezervasyonPayload<ExtArgs>, T, "findMany"> | Null>
    durumlar<T extends Oda$durumlarArgs<ExtArgs> = {}>(args?: Subset<T, Oda$durumlarArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OdaDurumuPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Oda model
   */ 
  interface OdaFieldRefs {
    readonly id: FieldRef<"Oda", 'Int'>
    readonly numara: FieldRef<"Oda", 'String'>
    readonly tip: FieldRef<"Oda", 'String'>
    readonly fiyat: FieldRef<"Oda", 'Float'>
    readonly kapasite: FieldRef<"Oda", 'Int'>
    readonly otelId: FieldRef<"Oda", 'Int'>
    readonly createdAt: FieldRef<"Oda", 'DateTime'>
    readonly updatedAt: FieldRef<"Oda", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Oda findUnique
   */
  export type OdaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Oda
     */
    select?: OdaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OdaInclude<ExtArgs> | null
    /**
     * Filter, which Oda to fetch.
     */
    where: OdaWhereUniqueInput
  }

  /**
   * Oda findUniqueOrThrow
   */
  export type OdaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Oda
     */
    select?: OdaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OdaInclude<ExtArgs> | null
    /**
     * Filter, which Oda to fetch.
     */
    where: OdaWhereUniqueInput
  }

  /**
   * Oda findFirst
   */
  export type OdaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Oda
     */
    select?: OdaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OdaInclude<ExtArgs> | null
    /**
     * Filter, which Oda to fetch.
     */
    where?: OdaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Odas to fetch.
     */
    orderBy?: OdaOrderByWithRelationInput | OdaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Odas.
     */
    cursor?: OdaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Odas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Odas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Odas.
     */
    distinct?: OdaScalarFieldEnum | OdaScalarFieldEnum[]
  }

  /**
   * Oda findFirstOrThrow
   */
  export type OdaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Oda
     */
    select?: OdaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OdaInclude<ExtArgs> | null
    /**
     * Filter, which Oda to fetch.
     */
    where?: OdaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Odas to fetch.
     */
    orderBy?: OdaOrderByWithRelationInput | OdaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Odas.
     */
    cursor?: OdaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Odas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Odas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Odas.
     */
    distinct?: OdaScalarFieldEnum | OdaScalarFieldEnum[]
  }

  /**
   * Oda findMany
   */
  export type OdaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Oda
     */
    select?: OdaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OdaInclude<ExtArgs> | null
    /**
     * Filter, which Odas to fetch.
     */
    where?: OdaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Odas to fetch.
     */
    orderBy?: OdaOrderByWithRelationInput | OdaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Odas.
     */
    cursor?: OdaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Odas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Odas.
     */
    skip?: number
    distinct?: OdaScalarFieldEnum | OdaScalarFieldEnum[]
  }

  /**
   * Oda create
   */
  export type OdaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Oda
     */
    select?: OdaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OdaInclude<ExtArgs> | null
    /**
     * The data needed to create a Oda.
     */
    data: XOR<OdaCreateInput, OdaUncheckedCreateInput>
  }

  /**
   * Oda createMany
   */
  export type OdaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Odas.
     */
    data: OdaCreateManyInput | OdaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Oda createManyAndReturn
   */
  export type OdaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Oda
     */
    select?: OdaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Odas.
     */
    data: OdaCreateManyInput | OdaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OdaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Oda update
   */
  export type OdaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Oda
     */
    select?: OdaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OdaInclude<ExtArgs> | null
    /**
     * The data needed to update a Oda.
     */
    data: XOR<OdaUpdateInput, OdaUncheckedUpdateInput>
    /**
     * Choose, which Oda to update.
     */
    where: OdaWhereUniqueInput
  }

  /**
   * Oda updateMany
   */
  export type OdaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Odas.
     */
    data: XOR<OdaUpdateManyMutationInput, OdaUncheckedUpdateManyInput>
    /**
     * Filter which Odas to update
     */
    where?: OdaWhereInput
  }

  /**
   * Oda upsert
   */
  export type OdaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Oda
     */
    select?: OdaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OdaInclude<ExtArgs> | null
    /**
     * The filter to search for the Oda to update in case it exists.
     */
    where: OdaWhereUniqueInput
    /**
     * In case the Oda found by the `where` argument doesn't exist, create a new Oda with this data.
     */
    create: XOR<OdaCreateInput, OdaUncheckedCreateInput>
    /**
     * In case the Oda was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OdaUpdateInput, OdaUncheckedUpdateInput>
  }

  /**
   * Oda delete
   */
  export type OdaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Oda
     */
    select?: OdaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OdaInclude<ExtArgs> | null
    /**
     * Filter which Oda to delete.
     */
    where: OdaWhereUniqueInput
  }

  /**
   * Oda deleteMany
   */
  export type OdaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Odas to delete
     */
    where?: OdaWhereInput
  }

  /**
   * Oda.rezervasyonlar
   */
  export type Oda$rezervasyonlarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rezervasyon
     */
    select?: RezervasyonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RezervasyonInclude<ExtArgs> | null
    where?: RezervasyonWhereInput
    orderBy?: RezervasyonOrderByWithRelationInput | RezervasyonOrderByWithRelationInput[]
    cursor?: RezervasyonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RezervasyonScalarFieldEnum | RezervasyonScalarFieldEnum[]
  }

  /**
   * Oda.durumlar
   */
  export type Oda$durumlarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OdaDurumu
     */
    select?: OdaDurumuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OdaDurumuInclude<ExtArgs> | null
    where?: OdaDurumuWhereInput
    orderBy?: OdaDurumuOrderByWithRelationInput | OdaDurumuOrderByWithRelationInput[]
    cursor?: OdaDurumuWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OdaDurumuScalarFieldEnum | OdaDurumuScalarFieldEnum[]
  }

  /**
   * Oda without action
   */
  export type OdaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Oda
     */
    select?: OdaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OdaInclude<ExtArgs> | null
  }


  /**
   * Model Rezervasyon
   */

  export type AggregateRezervasyon = {
    _count: RezervasyonCountAggregateOutputType | null
    _avg: RezervasyonAvgAggregateOutputType | null
    _sum: RezervasyonSumAggregateOutputType | null
    _min: RezervasyonMinAggregateOutputType | null
    _max: RezervasyonMaxAggregateOutputType | null
  }

  export type RezervasyonAvgAggregateOutputType = {
    id: number | null
    musteriId: number | null
    odaId: number | null
    toplamFiyat: number | null
  }

  export type RezervasyonSumAggregateOutputType = {
    id: number | null
    musteriId: number | null
    odaId: number | null
    toplamFiyat: number | null
  }

  export type RezervasyonMinAggregateOutputType = {
    id: number | null
    musteriId: number | null
    odaId: number | null
    girisTarihi: Date | null
    cikisTarihi: Date | null
    toplamFiyat: number | null
    durum: $Enums.RezervasyonDurumu | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RezervasyonMaxAggregateOutputType = {
    id: number | null
    musteriId: number | null
    odaId: number | null
    girisTarihi: Date | null
    cikisTarihi: Date | null
    toplamFiyat: number | null
    durum: $Enums.RezervasyonDurumu | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RezervasyonCountAggregateOutputType = {
    id: number
    musteriId: number
    odaId: number
    girisTarihi: number
    cikisTarihi: number
    toplamFiyat: number
    durum: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RezervasyonAvgAggregateInputType = {
    id?: true
    musteriId?: true
    odaId?: true
    toplamFiyat?: true
  }

  export type RezervasyonSumAggregateInputType = {
    id?: true
    musteriId?: true
    odaId?: true
    toplamFiyat?: true
  }

  export type RezervasyonMinAggregateInputType = {
    id?: true
    musteriId?: true
    odaId?: true
    girisTarihi?: true
    cikisTarihi?: true
    toplamFiyat?: true
    durum?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RezervasyonMaxAggregateInputType = {
    id?: true
    musteriId?: true
    odaId?: true
    girisTarihi?: true
    cikisTarihi?: true
    toplamFiyat?: true
    durum?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RezervasyonCountAggregateInputType = {
    id?: true
    musteriId?: true
    odaId?: true
    girisTarihi?: true
    cikisTarihi?: true
    toplamFiyat?: true
    durum?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RezervasyonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rezervasyon to aggregate.
     */
    where?: RezervasyonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rezervasyons to fetch.
     */
    orderBy?: RezervasyonOrderByWithRelationInput | RezervasyonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RezervasyonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rezervasyons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rezervasyons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rezervasyons
    **/
    _count?: true | RezervasyonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RezervasyonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RezervasyonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RezervasyonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RezervasyonMaxAggregateInputType
  }

  export type GetRezervasyonAggregateType<T extends RezervasyonAggregateArgs> = {
        [P in keyof T & keyof AggregateRezervasyon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRezervasyon[P]>
      : GetScalarType<T[P], AggregateRezervasyon[P]>
  }




  export type RezervasyonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RezervasyonWhereInput
    orderBy?: RezervasyonOrderByWithAggregationInput | RezervasyonOrderByWithAggregationInput[]
    by: RezervasyonScalarFieldEnum[] | RezervasyonScalarFieldEnum
    having?: RezervasyonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RezervasyonCountAggregateInputType | true
    _avg?: RezervasyonAvgAggregateInputType
    _sum?: RezervasyonSumAggregateInputType
    _min?: RezervasyonMinAggregateInputType
    _max?: RezervasyonMaxAggregateInputType
  }

  export type RezervasyonGroupByOutputType = {
    id: number
    musteriId: number
    odaId: number
    girisTarihi: Date
    cikisTarihi: Date
    toplamFiyat: number
    durum: $Enums.RezervasyonDurumu
    createdAt: Date
    updatedAt: Date
    _count: RezervasyonCountAggregateOutputType | null
    _avg: RezervasyonAvgAggregateOutputType | null
    _sum: RezervasyonSumAggregateOutputType | null
    _min: RezervasyonMinAggregateOutputType | null
    _max: RezervasyonMaxAggregateOutputType | null
  }

  type GetRezervasyonGroupByPayload<T extends RezervasyonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RezervasyonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RezervasyonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RezervasyonGroupByOutputType[P]>
            : GetScalarType<T[P], RezervasyonGroupByOutputType[P]>
        }
      >
    >


  export type RezervasyonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    musteriId?: boolean
    odaId?: boolean
    girisTarihi?: boolean
    cikisTarihi?: boolean
    toplamFiyat?: boolean
    durum?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    musteri?: boolean | MusteriDefaultArgs<ExtArgs>
    oda?: boolean | OdaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rezervasyon"]>

  export type RezervasyonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    musteriId?: boolean
    odaId?: boolean
    girisTarihi?: boolean
    cikisTarihi?: boolean
    toplamFiyat?: boolean
    durum?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    musteri?: boolean | MusteriDefaultArgs<ExtArgs>
    oda?: boolean | OdaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rezervasyon"]>

  export type RezervasyonSelectScalar = {
    id?: boolean
    musteriId?: boolean
    odaId?: boolean
    girisTarihi?: boolean
    cikisTarihi?: boolean
    toplamFiyat?: boolean
    durum?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RezervasyonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    musteri?: boolean | MusteriDefaultArgs<ExtArgs>
    oda?: boolean | OdaDefaultArgs<ExtArgs>
  }
  export type RezervasyonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    musteri?: boolean | MusteriDefaultArgs<ExtArgs>
    oda?: boolean | OdaDefaultArgs<ExtArgs>
  }

  export type $RezervasyonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rezervasyon"
    objects: {
      musteri: Prisma.$MusteriPayload<ExtArgs>
      oda: Prisma.$OdaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      musteriId: number
      odaId: number
      girisTarihi: Date
      cikisTarihi: Date
      toplamFiyat: number
      durum: $Enums.RezervasyonDurumu
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rezervasyon"]>
    composites: {}
  }

  type RezervasyonGetPayload<S extends boolean | null | undefined | RezervasyonDefaultArgs> = $Result.GetResult<Prisma.$RezervasyonPayload, S>

  type RezervasyonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RezervasyonFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RezervasyonCountAggregateInputType | true
    }

  export interface RezervasyonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rezervasyon'], meta: { name: 'Rezervasyon' } }
    /**
     * Find zero or one Rezervasyon that matches the filter.
     * @param {RezervasyonFindUniqueArgs} args - Arguments to find a Rezervasyon
     * @example
     * // Get one Rezervasyon
     * const rezervasyon = await prisma.rezervasyon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RezervasyonFindUniqueArgs>(args: SelectSubset<T, RezervasyonFindUniqueArgs<ExtArgs>>): Prisma__RezervasyonClient<$Result.GetResult<Prisma.$RezervasyonPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Rezervasyon that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RezervasyonFindUniqueOrThrowArgs} args - Arguments to find a Rezervasyon
     * @example
     * // Get one Rezervasyon
     * const rezervasyon = await prisma.rezervasyon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RezervasyonFindUniqueOrThrowArgs>(args: SelectSubset<T, RezervasyonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RezervasyonClient<$Result.GetResult<Prisma.$RezervasyonPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Rezervasyon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RezervasyonFindFirstArgs} args - Arguments to find a Rezervasyon
     * @example
     * // Get one Rezervasyon
     * const rezervasyon = await prisma.rezervasyon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RezervasyonFindFirstArgs>(args?: SelectSubset<T, RezervasyonFindFirstArgs<ExtArgs>>): Prisma__RezervasyonClient<$Result.GetResult<Prisma.$RezervasyonPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Rezervasyon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RezervasyonFindFirstOrThrowArgs} args - Arguments to find a Rezervasyon
     * @example
     * // Get one Rezervasyon
     * const rezervasyon = await prisma.rezervasyon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RezervasyonFindFirstOrThrowArgs>(args?: SelectSubset<T, RezervasyonFindFirstOrThrowArgs<ExtArgs>>): Prisma__RezervasyonClient<$Result.GetResult<Prisma.$RezervasyonPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Rezervasyons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RezervasyonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rezervasyons
     * const rezervasyons = await prisma.rezervasyon.findMany()
     * 
     * // Get first 10 Rezervasyons
     * const rezervasyons = await prisma.rezervasyon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rezervasyonWithIdOnly = await prisma.rezervasyon.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RezervasyonFindManyArgs>(args?: SelectSubset<T, RezervasyonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RezervasyonPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Rezervasyon.
     * @param {RezervasyonCreateArgs} args - Arguments to create a Rezervasyon.
     * @example
     * // Create one Rezervasyon
     * const Rezervasyon = await prisma.rezervasyon.create({
     *   data: {
     *     // ... data to create a Rezervasyon
     *   }
     * })
     * 
     */
    create<T extends RezervasyonCreateArgs>(args: SelectSubset<T, RezervasyonCreateArgs<ExtArgs>>): Prisma__RezervasyonClient<$Result.GetResult<Prisma.$RezervasyonPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Rezervasyons.
     * @param {RezervasyonCreateManyArgs} args - Arguments to create many Rezervasyons.
     * @example
     * // Create many Rezervasyons
     * const rezervasyon = await prisma.rezervasyon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RezervasyonCreateManyArgs>(args?: SelectSubset<T, RezervasyonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rezervasyons and returns the data saved in the database.
     * @param {RezervasyonCreateManyAndReturnArgs} args - Arguments to create many Rezervasyons.
     * @example
     * // Create many Rezervasyons
     * const rezervasyon = await prisma.rezervasyon.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rezervasyons and only return the `id`
     * const rezervasyonWithIdOnly = await prisma.rezervasyon.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RezervasyonCreateManyAndReturnArgs>(args?: SelectSubset<T, RezervasyonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RezervasyonPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Rezervasyon.
     * @param {RezervasyonDeleteArgs} args - Arguments to delete one Rezervasyon.
     * @example
     * // Delete one Rezervasyon
     * const Rezervasyon = await prisma.rezervasyon.delete({
     *   where: {
     *     // ... filter to delete one Rezervasyon
     *   }
     * })
     * 
     */
    delete<T extends RezervasyonDeleteArgs>(args: SelectSubset<T, RezervasyonDeleteArgs<ExtArgs>>): Prisma__RezervasyonClient<$Result.GetResult<Prisma.$RezervasyonPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Rezervasyon.
     * @param {RezervasyonUpdateArgs} args - Arguments to update one Rezervasyon.
     * @example
     * // Update one Rezervasyon
     * const rezervasyon = await prisma.rezervasyon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RezervasyonUpdateArgs>(args: SelectSubset<T, RezervasyonUpdateArgs<ExtArgs>>): Prisma__RezervasyonClient<$Result.GetResult<Prisma.$RezervasyonPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Rezervasyons.
     * @param {RezervasyonDeleteManyArgs} args - Arguments to filter Rezervasyons to delete.
     * @example
     * // Delete a few Rezervasyons
     * const { count } = await prisma.rezervasyon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RezervasyonDeleteManyArgs>(args?: SelectSubset<T, RezervasyonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rezervasyons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RezervasyonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rezervasyons
     * const rezervasyon = await prisma.rezervasyon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RezervasyonUpdateManyArgs>(args: SelectSubset<T, RezervasyonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rezervasyon.
     * @param {RezervasyonUpsertArgs} args - Arguments to update or create a Rezervasyon.
     * @example
     * // Update or create a Rezervasyon
     * const rezervasyon = await prisma.rezervasyon.upsert({
     *   create: {
     *     // ... data to create a Rezervasyon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rezervasyon we want to update
     *   }
     * })
     */
    upsert<T extends RezervasyonUpsertArgs>(args: SelectSubset<T, RezervasyonUpsertArgs<ExtArgs>>): Prisma__RezervasyonClient<$Result.GetResult<Prisma.$RezervasyonPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Rezervasyons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RezervasyonCountArgs} args - Arguments to filter Rezervasyons to count.
     * @example
     * // Count the number of Rezervasyons
     * const count = await prisma.rezervasyon.count({
     *   where: {
     *     // ... the filter for the Rezervasyons we want to count
     *   }
     * })
    **/
    count<T extends RezervasyonCountArgs>(
      args?: Subset<T, RezervasyonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RezervasyonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rezervasyon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RezervasyonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RezervasyonAggregateArgs>(args: Subset<T, RezervasyonAggregateArgs>): Prisma.PrismaPromise<GetRezervasyonAggregateType<T>>

    /**
     * Group by Rezervasyon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RezervasyonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RezervasyonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RezervasyonGroupByArgs['orderBy'] }
        : { orderBy?: RezervasyonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RezervasyonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRezervasyonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rezervasyon model
   */
  readonly fields: RezervasyonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rezervasyon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RezervasyonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    musteri<T extends MusteriDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MusteriDefaultArgs<ExtArgs>>): Prisma__MusteriClient<$Result.GetResult<Prisma.$MusteriPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    oda<T extends OdaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OdaDefaultArgs<ExtArgs>>): Prisma__OdaClient<$Result.GetResult<Prisma.$OdaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Rezervasyon model
   */ 
  interface RezervasyonFieldRefs {
    readonly id: FieldRef<"Rezervasyon", 'Int'>
    readonly musteriId: FieldRef<"Rezervasyon", 'Int'>
    readonly odaId: FieldRef<"Rezervasyon", 'Int'>
    readonly girisTarihi: FieldRef<"Rezervasyon", 'DateTime'>
    readonly cikisTarihi: FieldRef<"Rezervasyon", 'DateTime'>
    readonly toplamFiyat: FieldRef<"Rezervasyon", 'Float'>
    readonly durum: FieldRef<"Rezervasyon", 'RezervasyonDurumu'>
    readonly createdAt: FieldRef<"Rezervasyon", 'DateTime'>
    readonly updatedAt: FieldRef<"Rezervasyon", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Rezervasyon findUnique
   */
  export type RezervasyonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rezervasyon
     */
    select?: RezervasyonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RezervasyonInclude<ExtArgs> | null
    /**
     * Filter, which Rezervasyon to fetch.
     */
    where: RezervasyonWhereUniqueInput
  }

  /**
   * Rezervasyon findUniqueOrThrow
   */
  export type RezervasyonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rezervasyon
     */
    select?: RezervasyonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RezervasyonInclude<ExtArgs> | null
    /**
     * Filter, which Rezervasyon to fetch.
     */
    where: RezervasyonWhereUniqueInput
  }

  /**
   * Rezervasyon findFirst
   */
  export type RezervasyonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rezervasyon
     */
    select?: RezervasyonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RezervasyonInclude<ExtArgs> | null
    /**
     * Filter, which Rezervasyon to fetch.
     */
    where?: RezervasyonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rezervasyons to fetch.
     */
    orderBy?: RezervasyonOrderByWithRelationInput | RezervasyonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rezervasyons.
     */
    cursor?: RezervasyonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rezervasyons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rezervasyons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rezervasyons.
     */
    distinct?: RezervasyonScalarFieldEnum | RezervasyonScalarFieldEnum[]
  }

  /**
   * Rezervasyon findFirstOrThrow
   */
  export type RezervasyonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rezervasyon
     */
    select?: RezervasyonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RezervasyonInclude<ExtArgs> | null
    /**
     * Filter, which Rezervasyon to fetch.
     */
    where?: RezervasyonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rezervasyons to fetch.
     */
    orderBy?: RezervasyonOrderByWithRelationInput | RezervasyonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rezervasyons.
     */
    cursor?: RezervasyonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rezervasyons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rezervasyons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rezervasyons.
     */
    distinct?: RezervasyonScalarFieldEnum | RezervasyonScalarFieldEnum[]
  }

  /**
   * Rezervasyon findMany
   */
  export type RezervasyonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rezervasyon
     */
    select?: RezervasyonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RezervasyonInclude<ExtArgs> | null
    /**
     * Filter, which Rezervasyons to fetch.
     */
    where?: RezervasyonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rezervasyons to fetch.
     */
    orderBy?: RezervasyonOrderByWithRelationInput | RezervasyonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rezervasyons.
     */
    cursor?: RezervasyonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rezervasyons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rezervasyons.
     */
    skip?: number
    distinct?: RezervasyonScalarFieldEnum | RezervasyonScalarFieldEnum[]
  }

  /**
   * Rezervasyon create
   */
  export type RezervasyonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rezervasyon
     */
    select?: RezervasyonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RezervasyonInclude<ExtArgs> | null
    /**
     * The data needed to create a Rezervasyon.
     */
    data: XOR<RezervasyonCreateInput, RezervasyonUncheckedCreateInput>
  }

  /**
   * Rezervasyon createMany
   */
  export type RezervasyonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rezervasyons.
     */
    data: RezervasyonCreateManyInput | RezervasyonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rezervasyon createManyAndReturn
   */
  export type RezervasyonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rezervasyon
     */
    select?: RezervasyonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Rezervasyons.
     */
    data: RezervasyonCreateManyInput | RezervasyonCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RezervasyonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Rezervasyon update
   */
  export type RezervasyonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rezervasyon
     */
    select?: RezervasyonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RezervasyonInclude<ExtArgs> | null
    /**
     * The data needed to update a Rezervasyon.
     */
    data: XOR<RezervasyonUpdateInput, RezervasyonUncheckedUpdateInput>
    /**
     * Choose, which Rezervasyon to update.
     */
    where: RezervasyonWhereUniqueInput
  }

  /**
   * Rezervasyon updateMany
   */
  export type RezervasyonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rezervasyons.
     */
    data: XOR<RezervasyonUpdateManyMutationInput, RezervasyonUncheckedUpdateManyInput>
    /**
     * Filter which Rezervasyons to update
     */
    where?: RezervasyonWhereInput
  }

  /**
   * Rezervasyon upsert
   */
  export type RezervasyonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rezervasyon
     */
    select?: RezervasyonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RezervasyonInclude<ExtArgs> | null
    /**
     * The filter to search for the Rezervasyon to update in case it exists.
     */
    where: RezervasyonWhereUniqueInput
    /**
     * In case the Rezervasyon found by the `where` argument doesn't exist, create a new Rezervasyon with this data.
     */
    create: XOR<RezervasyonCreateInput, RezervasyonUncheckedCreateInput>
    /**
     * In case the Rezervasyon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RezervasyonUpdateInput, RezervasyonUncheckedUpdateInput>
  }

  /**
   * Rezervasyon delete
   */
  export type RezervasyonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rezervasyon
     */
    select?: RezervasyonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RezervasyonInclude<ExtArgs> | null
    /**
     * Filter which Rezervasyon to delete.
     */
    where: RezervasyonWhereUniqueInput
  }

  /**
   * Rezervasyon deleteMany
   */
  export type RezervasyonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rezervasyons to delete
     */
    where?: RezervasyonWhereInput
  }

  /**
   * Rezervasyon without action
   */
  export type RezervasyonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rezervasyon
     */
    select?: RezervasyonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RezervasyonInclude<ExtArgs> | null
  }


  /**
   * Model OdaDurumu
   */

  export type AggregateOdaDurumu = {
    _count: OdaDurumuCountAggregateOutputType | null
    _avg: OdaDurumuAvgAggregateOutputType | null
    _sum: OdaDurumuSumAggregateOutputType | null
    _min: OdaDurumuMinAggregateOutputType | null
    _max: OdaDurumuMaxAggregateOutputType | null
  }

  export type OdaDurumuAvgAggregateOutputType = {
    id: number | null
    odaId: number | null
  }

  export type OdaDurumuSumAggregateOutputType = {
    id: number | null
    odaId: number | null
  }

  export type OdaDurumuMinAggregateOutputType = {
    id: number | null
    odaId: number | null
    tarih: Date | null
    durum: $Enums.OdaDurumTipi | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OdaDurumuMaxAggregateOutputType = {
    id: number | null
    odaId: number | null
    tarih: Date | null
    durum: $Enums.OdaDurumTipi | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OdaDurumuCountAggregateOutputType = {
    id: number
    odaId: number
    tarih: number
    durum: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OdaDurumuAvgAggregateInputType = {
    id?: true
    odaId?: true
  }

  export type OdaDurumuSumAggregateInputType = {
    id?: true
    odaId?: true
  }

  export type OdaDurumuMinAggregateInputType = {
    id?: true
    odaId?: true
    tarih?: true
    durum?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OdaDurumuMaxAggregateInputType = {
    id?: true
    odaId?: true
    tarih?: true
    durum?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OdaDurumuCountAggregateInputType = {
    id?: true
    odaId?: true
    tarih?: true
    durum?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OdaDurumuAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OdaDurumu to aggregate.
     */
    where?: OdaDurumuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OdaDurumus to fetch.
     */
    orderBy?: OdaDurumuOrderByWithRelationInput | OdaDurumuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OdaDurumuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OdaDurumus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OdaDurumus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OdaDurumus
    **/
    _count?: true | OdaDurumuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OdaDurumuAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OdaDurumuSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OdaDurumuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OdaDurumuMaxAggregateInputType
  }

  export type GetOdaDurumuAggregateType<T extends OdaDurumuAggregateArgs> = {
        [P in keyof T & keyof AggregateOdaDurumu]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOdaDurumu[P]>
      : GetScalarType<T[P], AggregateOdaDurumu[P]>
  }




  export type OdaDurumuGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OdaDurumuWhereInput
    orderBy?: OdaDurumuOrderByWithAggregationInput | OdaDurumuOrderByWithAggregationInput[]
    by: OdaDurumuScalarFieldEnum[] | OdaDurumuScalarFieldEnum
    having?: OdaDurumuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OdaDurumuCountAggregateInputType | true
    _avg?: OdaDurumuAvgAggregateInputType
    _sum?: OdaDurumuSumAggregateInputType
    _min?: OdaDurumuMinAggregateInputType
    _max?: OdaDurumuMaxAggregateInputType
  }

  export type OdaDurumuGroupByOutputType = {
    id: number
    odaId: number
    tarih: Date
    durum: $Enums.OdaDurumTipi
    createdAt: Date
    updatedAt: Date
    _count: OdaDurumuCountAggregateOutputType | null
    _avg: OdaDurumuAvgAggregateOutputType | null
    _sum: OdaDurumuSumAggregateOutputType | null
    _min: OdaDurumuMinAggregateOutputType | null
    _max: OdaDurumuMaxAggregateOutputType | null
  }

  type GetOdaDurumuGroupByPayload<T extends OdaDurumuGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OdaDurumuGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OdaDurumuGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OdaDurumuGroupByOutputType[P]>
            : GetScalarType<T[P], OdaDurumuGroupByOutputType[P]>
        }
      >
    >


  export type OdaDurumuSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    odaId?: boolean
    tarih?: boolean
    durum?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    oda?: boolean | OdaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["odaDurumu"]>

  export type OdaDurumuSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    odaId?: boolean
    tarih?: boolean
    durum?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    oda?: boolean | OdaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["odaDurumu"]>

  export type OdaDurumuSelectScalar = {
    id?: boolean
    odaId?: boolean
    tarih?: boolean
    durum?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OdaDurumuInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    oda?: boolean | OdaDefaultArgs<ExtArgs>
  }
  export type OdaDurumuIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    oda?: boolean | OdaDefaultArgs<ExtArgs>
  }

  export type $OdaDurumuPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OdaDurumu"
    objects: {
      oda: Prisma.$OdaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      odaId: number
      tarih: Date
      durum: $Enums.OdaDurumTipi
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["odaDurumu"]>
    composites: {}
  }

  type OdaDurumuGetPayload<S extends boolean | null | undefined | OdaDurumuDefaultArgs> = $Result.GetResult<Prisma.$OdaDurumuPayload, S>

  type OdaDurumuCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OdaDurumuFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OdaDurumuCountAggregateInputType | true
    }

  export interface OdaDurumuDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OdaDurumu'], meta: { name: 'OdaDurumu' } }
    /**
     * Find zero or one OdaDurumu that matches the filter.
     * @param {OdaDurumuFindUniqueArgs} args - Arguments to find a OdaDurumu
     * @example
     * // Get one OdaDurumu
     * const odaDurumu = await prisma.odaDurumu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OdaDurumuFindUniqueArgs>(args: SelectSubset<T, OdaDurumuFindUniqueArgs<ExtArgs>>): Prisma__OdaDurumuClient<$Result.GetResult<Prisma.$OdaDurumuPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OdaDurumu that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OdaDurumuFindUniqueOrThrowArgs} args - Arguments to find a OdaDurumu
     * @example
     * // Get one OdaDurumu
     * const odaDurumu = await prisma.odaDurumu.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OdaDurumuFindUniqueOrThrowArgs>(args: SelectSubset<T, OdaDurumuFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OdaDurumuClient<$Result.GetResult<Prisma.$OdaDurumuPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OdaDurumu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OdaDurumuFindFirstArgs} args - Arguments to find a OdaDurumu
     * @example
     * // Get one OdaDurumu
     * const odaDurumu = await prisma.odaDurumu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OdaDurumuFindFirstArgs>(args?: SelectSubset<T, OdaDurumuFindFirstArgs<ExtArgs>>): Prisma__OdaDurumuClient<$Result.GetResult<Prisma.$OdaDurumuPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OdaDurumu that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OdaDurumuFindFirstOrThrowArgs} args - Arguments to find a OdaDurumu
     * @example
     * // Get one OdaDurumu
     * const odaDurumu = await prisma.odaDurumu.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OdaDurumuFindFirstOrThrowArgs>(args?: SelectSubset<T, OdaDurumuFindFirstOrThrowArgs<ExtArgs>>): Prisma__OdaDurumuClient<$Result.GetResult<Prisma.$OdaDurumuPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OdaDurumus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OdaDurumuFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OdaDurumus
     * const odaDurumus = await prisma.odaDurumu.findMany()
     * 
     * // Get first 10 OdaDurumus
     * const odaDurumus = await prisma.odaDurumu.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const odaDurumuWithIdOnly = await prisma.odaDurumu.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OdaDurumuFindManyArgs>(args?: SelectSubset<T, OdaDurumuFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OdaDurumuPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OdaDurumu.
     * @param {OdaDurumuCreateArgs} args - Arguments to create a OdaDurumu.
     * @example
     * // Create one OdaDurumu
     * const OdaDurumu = await prisma.odaDurumu.create({
     *   data: {
     *     // ... data to create a OdaDurumu
     *   }
     * })
     * 
     */
    create<T extends OdaDurumuCreateArgs>(args: SelectSubset<T, OdaDurumuCreateArgs<ExtArgs>>): Prisma__OdaDurumuClient<$Result.GetResult<Prisma.$OdaDurumuPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OdaDurumus.
     * @param {OdaDurumuCreateManyArgs} args - Arguments to create many OdaDurumus.
     * @example
     * // Create many OdaDurumus
     * const odaDurumu = await prisma.odaDurumu.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OdaDurumuCreateManyArgs>(args?: SelectSubset<T, OdaDurumuCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OdaDurumus and returns the data saved in the database.
     * @param {OdaDurumuCreateManyAndReturnArgs} args - Arguments to create many OdaDurumus.
     * @example
     * // Create many OdaDurumus
     * const odaDurumu = await prisma.odaDurumu.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OdaDurumus and only return the `id`
     * const odaDurumuWithIdOnly = await prisma.odaDurumu.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OdaDurumuCreateManyAndReturnArgs>(args?: SelectSubset<T, OdaDurumuCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OdaDurumuPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OdaDurumu.
     * @param {OdaDurumuDeleteArgs} args - Arguments to delete one OdaDurumu.
     * @example
     * // Delete one OdaDurumu
     * const OdaDurumu = await prisma.odaDurumu.delete({
     *   where: {
     *     // ... filter to delete one OdaDurumu
     *   }
     * })
     * 
     */
    delete<T extends OdaDurumuDeleteArgs>(args: SelectSubset<T, OdaDurumuDeleteArgs<ExtArgs>>): Prisma__OdaDurumuClient<$Result.GetResult<Prisma.$OdaDurumuPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OdaDurumu.
     * @param {OdaDurumuUpdateArgs} args - Arguments to update one OdaDurumu.
     * @example
     * // Update one OdaDurumu
     * const odaDurumu = await prisma.odaDurumu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OdaDurumuUpdateArgs>(args: SelectSubset<T, OdaDurumuUpdateArgs<ExtArgs>>): Prisma__OdaDurumuClient<$Result.GetResult<Prisma.$OdaDurumuPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OdaDurumus.
     * @param {OdaDurumuDeleteManyArgs} args - Arguments to filter OdaDurumus to delete.
     * @example
     * // Delete a few OdaDurumus
     * const { count } = await prisma.odaDurumu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OdaDurumuDeleteManyArgs>(args?: SelectSubset<T, OdaDurumuDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OdaDurumus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OdaDurumuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OdaDurumus
     * const odaDurumu = await prisma.odaDurumu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OdaDurumuUpdateManyArgs>(args: SelectSubset<T, OdaDurumuUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OdaDurumu.
     * @param {OdaDurumuUpsertArgs} args - Arguments to update or create a OdaDurumu.
     * @example
     * // Update or create a OdaDurumu
     * const odaDurumu = await prisma.odaDurumu.upsert({
     *   create: {
     *     // ... data to create a OdaDurumu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OdaDurumu we want to update
     *   }
     * })
     */
    upsert<T extends OdaDurumuUpsertArgs>(args: SelectSubset<T, OdaDurumuUpsertArgs<ExtArgs>>): Prisma__OdaDurumuClient<$Result.GetResult<Prisma.$OdaDurumuPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OdaDurumus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OdaDurumuCountArgs} args - Arguments to filter OdaDurumus to count.
     * @example
     * // Count the number of OdaDurumus
     * const count = await prisma.odaDurumu.count({
     *   where: {
     *     // ... the filter for the OdaDurumus we want to count
     *   }
     * })
    **/
    count<T extends OdaDurumuCountArgs>(
      args?: Subset<T, OdaDurumuCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OdaDurumuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OdaDurumu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OdaDurumuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OdaDurumuAggregateArgs>(args: Subset<T, OdaDurumuAggregateArgs>): Prisma.PrismaPromise<GetOdaDurumuAggregateType<T>>

    /**
     * Group by OdaDurumu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OdaDurumuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OdaDurumuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OdaDurumuGroupByArgs['orderBy'] }
        : { orderBy?: OdaDurumuGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OdaDurumuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOdaDurumuGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OdaDurumu model
   */
  readonly fields: OdaDurumuFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OdaDurumu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OdaDurumuClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    oda<T extends OdaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OdaDefaultArgs<ExtArgs>>): Prisma__OdaClient<$Result.GetResult<Prisma.$OdaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OdaDurumu model
   */ 
  interface OdaDurumuFieldRefs {
    readonly id: FieldRef<"OdaDurumu", 'Int'>
    readonly odaId: FieldRef<"OdaDurumu", 'Int'>
    readonly tarih: FieldRef<"OdaDurumu", 'DateTime'>
    readonly durum: FieldRef<"OdaDurumu", 'OdaDurumTipi'>
    readonly createdAt: FieldRef<"OdaDurumu", 'DateTime'>
    readonly updatedAt: FieldRef<"OdaDurumu", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OdaDurumu findUnique
   */
  export type OdaDurumuFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OdaDurumu
     */
    select?: OdaDurumuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OdaDurumuInclude<ExtArgs> | null
    /**
     * Filter, which OdaDurumu to fetch.
     */
    where: OdaDurumuWhereUniqueInput
  }

  /**
   * OdaDurumu findUniqueOrThrow
   */
  export type OdaDurumuFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OdaDurumu
     */
    select?: OdaDurumuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OdaDurumuInclude<ExtArgs> | null
    /**
     * Filter, which OdaDurumu to fetch.
     */
    where: OdaDurumuWhereUniqueInput
  }

  /**
   * OdaDurumu findFirst
   */
  export type OdaDurumuFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OdaDurumu
     */
    select?: OdaDurumuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OdaDurumuInclude<ExtArgs> | null
    /**
     * Filter, which OdaDurumu to fetch.
     */
    where?: OdaDurumuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OdaDurumus to fetch.
     */
    orderBy?: OdaDurumuOrderByWithRelationInput | OdaDurumuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OdaDurumus.
     */
    cursor?: OdaDurumuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OdaDurumus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OdaDurumus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OdaDurumus.
     */
    distinct?: OdaDurumuScalarFieldEnum | OdaDurumuScalarFieldEnum[]
  }

  /**
   * OdaDurumu findFirstOrThrow
   */
  export type OdaDurumuFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OdaDurumu
     */
    select?: OdaDurumuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OdaDurumuInclude<ExtArgs> | null
    /**
     * Filter, which OdaDurumu to fetch.
     */
    where?: OdaDurumuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OdaDurumus to fetch.
     */
    orderBy?: OdaDurumuOrderByWithRelationInput | OdaDurumuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OdaDurumus.
     */
    cursor?: OdaDurumuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OdaDurumus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OdaDurumus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OdaDurumus.
     */
    distinct?: OdaDurumuScalarFieldEnum | OdaDurumuScalarFieldEnum[]
  }

  /**
   * OdaDurumu findMany
   */
  export type OdaDurumuFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OdaDurumu
     */
    select?: OdaDurumuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OdaDurumuInclude<ExtArgs> | null
    /**
     * Filter, which OdaDurumus to fetch.
     */
    where?: OdaDurumuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OdaDurumus to fetch.
     */
    orderBy?: OdaDurumuOrderByWithRelationInput | OdaDurumuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OdaDurumus.
     */
    cursor?: OdaDurumuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OdaDurumus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OdaDurumus.
     */
    skip?: number
    distinct?: OdaDurumuScalarFieldEnum | OdaDurumuScalarFieldEnum[]
  }

  /**
   * OdaDurumu create
   */
  export type OdaDurumuCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OdaDurumu
     */
    select?: OdaDurumuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OdaDurumuInclude<ExtArgs> | null
    /**
     * The data needed to create a OdaDurumu.
     */
    data: XOR<OdaDurumuCreateInput, OdaDurumuUncheckedCreateInput>
  }

  /**
   * OdaDurumu createMany
   */
  export type OdaDurumuCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OdaDurumus.
     */
    data: OdaDurumuCreateManyInput | OdaDurumuCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OdaDurumu createManyAndReturn
   */
  export type OdaDurumuCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OdaDurumu
     */
    select?: OdaDurumuSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OdaDurumus.
     */
    data: OdaDurumuCreateManyInput | OdaDurumuCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OdaDurumuIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OdaDurumu update
   */
  export type OdaDurumuUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OdaDurumu
     */
    select?: OdaDurumuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OdaDurumuInclude<ExtArgs> | null
    /**
     * The data needed to update a OdaDurumu.
     */
    data: XOR<OdaDurumuUpdateInput, OdaDurumuUncheckedUpdateInput>
    /**
     * Choose, which OdaDurumu to update.
     */
    where: OdaDurumuWhereUniqueInput
  }

  /**
   * OdaDurumu updateMany
   */
  export type OdaDurumuUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OdaDurumus.
     */
    data: XOR<OdaDurumuUpdateManyMutationInput, OdaDurumuUncheckedUpdateManyInput>
    /**
     * Filter which OdaDurumus to update
     */
    where?: OdaDurumuWhereInput
  }

  /**
   * OdaDurumu upsert
   */
  export type OdaDurumuUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OdaDurumu
     */
    select?: OdaDurumuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OdaDurumuInclude<ExtArgs> | null
    /**
     * The filter to search for the OdaDurumu to update in case it exists.
     */
    where: OdaDurumuWhereUniqueInput
    /**
     * In case the OdaDurumu found by the `where` argument doesn't exist, create a new OdaDurumu with this data.
     */
    create: XOR<OdaDurumuCreateInput, OdaDurumuUncheckedCreateInput>
    /**
     * In case the OdaDurumu was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OdaDurumuUpdateInput, OdaDurumuUncheckedUpdateInput>
  }

  /**
   * OdaDurumu delete
   */
  export type OdaDurumuDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OdaDurumu
     */
    select?: OdaDurumuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OdaDurumuInclude<ExtArgs> | null
    /**
     * Filter which OdaDurumu to delete.
     */
    where: OdaDurumuWhereUniqueInput
  }

  /**
   * OdaDurumu deleteMany
   */
  export type OdaDurumuDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OdaDurumus to delete
     */
    where?: OdaDurumuWhereInput
  }

  /**
   * OdaDurumu without action
   */
  export type OdaDurumuDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OdaDurumu
     */
    select?: OdaDurumuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OdaDurumuInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const MusteriScalarFieldEnum: {
    id: 'id',
    ad: 'ad',
    soyad: 'soyad',
    email: 'email',
    telefon: 'telefon',
    sifre: 'sifre',
    rol: 'rol',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MusteriScalarFieldEnum = (typeof MusteriScalarFieldEnum)[keyof typeof MusteriScalarFieldEnum]


  export const OtelScalarFieldEnum: {
    id: 'id',
    ad: 'ad',
    adres: 'adres',
    sehir: 'sehir',
    yildiz: 'yildiz',
    aciklama: 'aciklama',
    yoneticiId: 'yoneticiId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OtelScalarFieldEnum = (typeof OtelScalarFieldEnum)[keyof typeof OtelScalarFieldEnum]


  export const OdaScalarFieldEnum: {
    id: 'id',
    numara: 'numara',
    tip: 'tip',
    fiyat: 'fiyat',
    kapasite: 'kapasite',
    otelId: 'otelId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OdaScalarFieldEnum = (typeof OdaScalarFieldEnum)[keyof typeof OdaScalarFieldEnum]


  export const RezervasyonScalarFieldEnum: {
    id: 'id',
    musteriId: 'musteriId',
    odaId: 'odaId',
    girisTarihi: 'girisTarihi',
    cikisTarihi: 'cikisTarihi',
    toplamFiyat: 'toplamFiyat',
    durum: 'durum',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RezervasyonScalarFieldEnum = (typeof RezervasyonScalarFieldEnum)[keyof typeof RezervasyonScalarFieldEnum]


  export const OdaDurumuScalarFieldEnum: {
    id: 'id',
    odaId: 'odaId',
    tarih: 'tarih',
    durum: 'durum',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OdaDurumuScalarFieldEnum = (typeof OdaDurumuScalarFieldEnum)[keyof typeof OdaDurumuScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Rol'
   */
  export type EnumRolFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Rol'>
    


  /**
   * Reference to a field of type 'Rol[]'
   */
  export type ListEnumRolFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Rol[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'RezervasyonDurumu'
   */
  export type EnumRezervasyonDurumuFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RezervasyonDurumu'>
    


  /**
   * Reference to a field of type 'RezervasyonDurumu[]'
   */
  export type ListEnumRezervasyonDurumuFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RezervasyonDurumu[]'>
    


  /**
   * Reference to a field of type 'OdaDurumTipi'
   */
  export type EnumOdaDurumTipiFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OdaDurumTipi'>
    


  /**
   * Reference to a field of type 'OdaDurumTipi[]'
   */
  export type ListEnumOdaDurumTipiFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OdaDurumTipi[]'>
    
  /**
   * Deep Input Types
   */


  export type MusteriWhereInput = {
    AND?: MusteriWhereInput | MusteriWhereInput[]
    OR?: MusteriWhereInput[]
    NOT?: MusteriWhereInput | MusteriWhereInput[]
    id?: IntFilter<"Musteri"> | number
    ad?: StringFilter<"Musteri"> | string
    soyad?: StringFilter<"Musteri"> | string
    email?: StringFilter<"Musteri"> | string
    telefon?: StringFilter<"Musteri"> | string
    sifre?: StringFilter<"Musteri"> | string
    rol?: EnumRolFilter<"Musteri"> | $Enums.Rol
    createdAt?: DateTimeFilter<"Musteri"> | Date | string
    updatedAt?: DateTimeFilter<"Musteri"> | Date | string
    rezervasyonlar?: RezervasyonListRelationFilter
    yoneticiOlduguOteller?: OtelListRelationFilter
  }

  export type MusteriOrderByWithRelationInput = {
    id?: SortOrder
    ad?: SortOrder
    soyad?: SortOrder
    email?: SortOrder
    telefon?: SortOrder
    sifre?: SortOrder
    rol?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rezervasyonlar?: RezervasyonOrderByRelationAggregateInput
    yoneticiOlduguOteller?: OtelOrderByRelationAggregateInput
  }

  export type MusteriWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: MusteriWhereInput | MusteriWhereInput[]
    OR?: MusteriWhereInput[]
    NOT?: MusteriWhereInput | MusteriWhereInput[]
    ad?: StringFilter<"Musteri"> | string
    soyad?: StringFilter<"Musteri"> | string
    telefon?: StringFilter<"Musteri"> | string
    sifre?: StringFilter<"Musteri"> | string
    rol?: EnumRolFilter<"Musteri"> | $Enums.Rol
    createdAt?: DateTimeFilter<"Musteri"> | Date | string
    updatedAt?: DateTimeFilter<"Musteri"> | Date | string
    rezervasyonlar?: RezervasyonListRelationFilter
    yoneticiOlduguOteller?: OtelListRelationFilter
  }, "id" | "email">

  export type MusteriOrderByWithAggregationInput = {
    id?: SortOrder
    ad?: SortOrder
    soyad?: SortOrder
    email?: SortOrder
    telefon?: SortOrder
    sifre?: SortOrder
    rol?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MusteriCountOrderByAggregateInput
    _avg?: MusteriAvgOrderByAggregateInput
    _max?: MusteriMaxOrderByAggregateInput
    _min?: MusteriMinOrderByAggregateInput
    _sum?: MusteriSumOrderByAggregateInput
  }

  export type MusteriScalarWhereWithAggregatesInput = {
    AND?: MusteriScalarWhereWithAggregatesInput | MusteriScalarWhereWithAggregatesInput[]
    OR?: MusteriScalarWhereWithAggregatesInput[]
    NOT?: MusteriScalarWhereWithAggregatesInput | MusteriScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Musteri"> | number
    ad?: StringWithAggregatesFilter<"Musteri"> | string
    soyad?: StringWithAggregatesFilter<"Musteri"> | string
    email?: StringWithAggregatesFilter<"Musteri"> | string
    telefon?: StringWithAggregatesFilter<"Musteri"> | string
    sifre?: StringWithAggregatesFilter<"Musteri"> | string
    rol?: EnumRolWithAggregatesFilter<"Musteri"> | $Enums.Rol
    createdAt?: DateTimeWithAggregatesFilter<"Musteri"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Musteri"> | Date | string
  }

  export type OtelWhereInput = {
    AND?: OtelWhereInput | OtelWhereInput[]
    OR?: OtelWhereInput[]
    NOT?: OtelWhereInput | OtelWhereInput[]
    id?: IntFilter<"Otel"> | number
    ad?: StringFilter<"Otel"> | string
    adres?: StringFilter<"Otel"> | string
    sehir?: StringFilter<"Otel"> | string
    yildiz?: IntFilter<"Otel"> | number
    aciklama?: StringNullableFilter<"Otel"> | string | null
    yoneticiId?: IntFilter<"Otel"> | number
    createdAt?: DateTimeFilter<"Otel"> | Date | string
    updatedAt?: DateTimeFilter<"Otel"> | Date | string
    yonetici?: XOR<MusteriRelationFilter, MusteriWhereInput>
    odalar?: OdaListRelationFilter
  }

  export type OtelOrderByWithRelationInput = {
    id?: SortOrder
    ad?: SortOrder
    adres?: SortOrder
    sehir?: SortOrder
    yildiz?: SortOrder
    aciklama?: SortOrderInput | SortOrder
    yoneticiId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yonetici?: MusteriOrderByWithRelationInput
    odalar?: OdaOrderByRelationAggregateInput
  }

  export type OtelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OtelWhereInput | OtelWhereInput[]
    OR?: OtelWhereInput[]
    NOT?: OtelWhereInput | OtelWhereInput[]
    ad?: StringFilter<"Otel"> | string
    adres?: StringFilter<"Otel"> | string
    sehir?: StringFilter<"Otel"> | string
    yildiz?: IntFilter<"Otel"> | number
    aciklama?: StringNullableFilter<"Otel"> | string | null
    yoneticiId?: IntFilter<"Otel"> | number
    createdAt?: DateTimeFilter<"Otel"> | Date | string
    updatedAt?: DateTimeFilter<"Otel"> | Date | string
    yonetici?: XOR<MusteriRelationFilter, MusteriWhereInput>
    odalar?: OdaListRelationFilter
  }, "id">

  export type OtelOrderByWithAggregationInput = {
    id?: SortOrder
    ad?: SortOrder
    adres?: SortOrder
    sehir?: SortOrder
    yildiz?: SortOrder
    aciklama?: SortOrderInput | SortOrder
    yoneticiId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OtelCountOrderByAggregateInput
    _avg?: OtelAvgOrderByAggregateInput
    _max?: OtelMaxOrderByAggregateInput
    _min?: OtelMinOrderByAggregateInput
    _sum?: OtelSumOrderByAggregateInput
  }

  export type OtelScalarWhereWithAggregatesInput = {
    AND?: OtelScalarWhereWithAggregatesInput | OtelScalarWhereWithAggregatesInput[]
    OR?: OtelScalarWhereWithAggregatesInput[]
    NOT?: OtelScalarWhereWithAggregatesInput | OtelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Otel"> | number
    ad?: StringWithAggregatesFilter<"Otel"> | string
    adres?: StringWithAggregatesFilter<"Otel"> | string
    sehir?: StringWithAggregatesFilter<"Otel"> | string
    yildiz?: IntWithAggregatesFilter<"Otel"> | number
    aciklama?: StringNullableWithAggregatesFilter<"Otel"> | string | null
    yoneticiId?: IntWithAggregatesFilter<"Otel"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Otel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Otel"> | Date | string
  }

  export type OdaWhereInput = {
    AND?: OdaWhereInput | OdaWhereInput[]
    OR?: OdaWhereInput[]
    NOT?: OdaWhereInput | OdaWhereInput[]
    id?: IntFilter<"Oda"> | number
    numara?: StringFilter<"Oda"> | string
    tip?: StringFilter<"Oda"> | string
    fiyat?: FloatFilter<"Oda"> | number
    kapasite?: IntFilter<"Oda"> | number
    otelId?: IntFilter<"Oda"> | number
    createdAt?: DateTimeFilter<"Oda"> | Date | string
    updatedAt?: DateTimeFilter<"Oda"> | Date | string
    otel?: XOR<OtelRelationFilter, OtelWhereInput>
    rezervasyonlar?: RezervasyonListRelationFilter
    durumlar?: OdaDurumuListRelationFilter
  }

  export type OdaOrderByWithRelationInput = {
    id?: SortOrder
    numara?: SortOrder
    tip?: SortOrder
    fiyat?: SortOrder
    kapasite?: SortOrder
    otelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    otel?: OtelOrderByWithRelationInput
    rezervasyonlar?: RezervasyonOrderByRelationAggregateInput
    durumlar?: OdaDurumuOrderByRelationAggregateInput
  }

  export type OdaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OdaWhereInput | OdaWhereInput[]
    OR?: OdaWhereInput[]
    NOT?: OdaWhereInput | OdaWhereInput[]
    numara?: StringFilter<"Oda"> | string
    tip?: StringFilter<"Oda"> | string
    fiyat?: FloatFilter<"Oda"> | number
    kapasite?: IntFilter<"Oda"> | number
    otelId?: IntFilter<"Oda"> | number
    createdAt?: DateTimeFilter<"Oda"> | Date | string
    updatedAt?: DateTimeFilter<"Oda"> | Date | string
    otel?: XOR<OtelRelationFilter, OtelWhereInput>
    rezervasyonlar?: RezervasyonListRelationFilter
    durumlar?: OdaDurumuListRelationFilter
  }, "id">

  export type OdaOrderByWithAggregationInput = {
    id?: SortOrder
    numara?: SortOrder
    tip?: SortOrder
    fiyat?: SortOrder
    kapasite?: SortOrder
    otelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OdaCountOrderByAggregateInput
    _avg?: OdaAvgOrderByAggregateInput
    _max?: OdaMaxOrderByAggregateInput
    _min?: OdaMinOrderByAggregateInput
    _sum?: OdaSumOrderByAggregateInput
  }

  export type OdaScalarWhereWithAggregatesInput = {
    AND?: OdaScalarWhereWithAggregatesInput | OdaScalarWhereWithAggregatesInput[]
    OR?: OdaScalarWhereWithAggregatesInput[]
    NOT?: OdaScalarWhereWithAggregatesInput | OdaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Oda"> | number
    numara?: StringWithAggregatesFilter<"Oda"> | string
    tip?: StringWithAggregatesFilter<"Oda"> | string
    fiyat?: FloatWithAggregatesFilter<"Oda"> | number
    kapasite?: IntWithAggregatesFilter<"Oda"> | number
    otelId?: IntWithAggregatesFilter<"Oda"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Oda"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Oda"> | Date | string
  }

  export type RezervasyonWhereInput = {
    AND?: RezervasyonWhereInput | RezervasyonWhereInput[]
    OR?: RezervasyonWhereInput[]
    NOT?: RezervasyonWhereInput | RezervasyonWhereInput[]
    id?: IntFilter<"Rezervasyon"> | number
    musteriId?: IntFilter<"Rezervasyon"> | number
    odaId?: IntFilter<"Rezervasyon"> | number
    girisTarihi?: DateTimeFilter<"Rezervasyon"> | Date | string
    cikisTarihi?: DateTimeFilter<"Rezervasyon"> | Date | string
    toplamFiyat?: FloatFilter<"Rezervasyon"> | number
    durum?: EnumRezervasyonDurumuFilter<"Rezervasyon"> | $Enums.RezervasyonDurumu
    createdAt?: DateTimeFilter<"Rezervasyon"> | Date | string
    updatedAt?: DateTimeFilter<"Rezervasyon"> | Date | string
    musteri?: XOR<MusteriRelationFilter, MusteriWhereInput>
    oda?: XOR<OdaRelationFilter, OdaWhereInput>
  }

  export type RezervasyonOrderByWithRelationInput = {
    id?: SortOrder
    musteriId?: SortOrder
    odaId?: SortOrder
    girisTarihi?: SortOrder
    cikisTarihi?: SortOrder
    toplamFiyat?: SortOrder
    durum?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    musteri?: MusteriOrderByWithRelationInput
    oda?: OdaOrderByWithRelationInput
  }

  export type RezervasyonWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RezervasyonWhereInput | RezervasyonWhereInput[]
    OR?: RezervasyonWhereInput[]
    NOT?: RezervasyonWhereInput | RezervasyonWhereInput[]
    musteriId?: IntFilter<"Rezervasyon"> | number
    odaId?: IntFilter<"Rezervasyon"> | number
    girisTarihi?: DateTimeFilter<"Rezervasyon"> | Date | string
    cikisTarihi?: DateTimeFilter<"Rezervasyon"> | Date | string
    toplamFiyat?: FloatFilter<"Rezervasyon"> | number
    durum?: EnumRezervasyonDurumuFilter<"Rezervasyon"> | $Enums.RezervasyonDurumu
    createdAt?: DateTimeFilter<"Rezervasyon"> | Date | string
    updatedAt?: DateTimeFilter<"Rezervasyon"> | Date | string
    musteri?: XOR<MusteriRelationFilter, MusteriWhereInput>
    oda?: XOR<OdaRelationFilter, OdaWhereInput>
  }, "id">

  export type RezervasyonOrderByWithAggregationInput = {
    id?: SortOrder
    musteriId?: SortOrder
    odaId?: SortOrder
    girisTarihi?: SortOrder
    cikisTarihi?: SortOrder
    toplamFiyat?: SortOrder
    durum?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RezervasyonCountOrderByAggregateInput
    _avg?: RezervasyonAvgOrderByAggregateInput
    _max?: RezervasyonMaxOrderByAggregateInput
    _min?: RezervasyonMinOrderByAggregateInput
    _sum?: RezervasyonSumOrderByAggregateInput
  }

  export type RezervasyonScalarWhereWithAggregatesInput = {
    AND?: RezervasyonScalarWhereWithAggregatesInput | RezervasyonScalarWhereWithAggregatesInput[]
    OR?: RezervasyonScalarWhereWithAggregatesInput[]
    NOT?: RezervasyonScalarWhereWithAggregatesInput | RezervasyonScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Rezervasyon"> | number
    musteriId?: IntWithAggregatesFilter<"Rezervasyon"> | number
    odaId?: IntWithAggregatesFilter<"Rezervasyon"> | number
    girisTarihi?: DateTimeWithAggregatesFilter<"Rezervasyon"> | Date | string
    cikisTarihi?: DateTimeWithAggregatesFilter<"Rezervasyon"> | Date | string
    toplamFiyat?: FloatWithAggregatesFilter<"Rezervasyon"> | number
    durum?: EnumRezervasyonDurumuWithAggregatesFilter<"Rezervasyon"> | $Enums.RezervasyonDurumu
    createdAt?: DateTimeWithAggregatesFilter<"Rezervasyon"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Rezervasyon"> | Date | string
  }

  export type OdaDurumuWhereInput = {
    AND?: OdaDurumuWhereInput | OdaDurumuWhereInput[]
    OR?: OdaDurumuWhereInput[]
    NOT?: OdaDurumuWhereInput | OdaDurumuWhereInput[]
    id?: IntFilter<"OdaDurumu"> | number
    odaId?: IntFilter<"OdaDurumu"> | number
    tarih?: DateTimeFilter<"OdaDurumu"> | Date | string
    durum?: EnumOdaDurumTipiFilter<"OdaDurumu"> | $Enums.OdaDurumTipi
    createdAt?: DateTimeFilter<"OdaDurumu"> | Date | string
    updatedAt?: DateTimeFilter<"OdaDurumu"> | Date | string
    oda?: XOR<OdaRelationFilter, OdaWhereInput>
  }

  export type OdaDurumuOrderByWithRelationInput = {
    id?: SortOrder
    odaId?: SortOrder
    tarih?: SortOrder
    durum?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    oda?: OdaOrderByWithRelationInput
  }

  export type OdaDurumuWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    odaId_tarih?: OdaDurumuOdaIdTarihCompoundUniqueInput
    AND?: OdaDurumuWhereInput | OdaDurumuWhereInput[]
    OR?: OdaDurumuWhereInput[]
    NOT?: OdaDurumuWhereInput | OdaDurumuWhereInput[]
    odaId?: IntFilter<"OdaDurumu"> | number
    tarih?: DateTimeFilter<"OdaDurumu"> | Date | string
    durum?: EnumOdaDurumTipiFilter<"OdaDurumu"> | $Enums.OdaDurumTipi
    createdAt?: DateTimeFilter<"OdaDurumu"> | Date | string
    updatedAt?: DateTimeFilter<"OdaDurumu"> | Date | string
    oda?: XOR<OdaRelationFilter, OdaWhereInput>
  }, "id" | "odaId_tarih">

  export type OdaDurumuOrderByWithAggregationInput = {
    id?: SortOrder
    odaId?: SortOrder
    tarih?: SortOrder
    durum?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OdaDurumuCountOrderByAggregateInput
    _avg?: OdaDurumuAvgOrderByAggregateInput
    _max?: OdaDurumuMaxOrderByAggregateInput
    _min?: OdaDurumuMinOrderByAggregateInput
    _sum?: OdaDurumuSumOrderByAggregateInput
  }

  export type OdaDurumuScalarWhereWithAggregatesInput = {
    AND?: OdaDurumuScalarWhereWithAggregatesInput | OdaDurumuScalarWhereWithAggregatesInput[]
    OR?: OdaDurumuScalarWhereWithAggregatesInput[]
    NOT?: OdaDurumuScalarWhereWithAggregatesInput | OdaDurumuScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OdaDurumu"> | number
    odaId?: IntWithAggregatesFilter<"OdaDurumu"> | number
    tarih?: DateTimeWithAggregatesFilter<"OdaDurumu"> | Date | string
    durum?: EnumOdaDurumTipiWithAggregatesFilter<"OdaDurumu"> | $Enums.OdaDurumTipi
    createdAt?: DateTimeWithAggregatesFilter<"OdaDurumu"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OdaDurumu"> | Date | string
  }

  export type MusteriCreateInput = {
    ad: string
    soyad: string
    email: string
    telefon: string
    sifre: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    rezervasyonlar?: RezervasyonCreateNestedManyWithoutMusteriInput
    yoneticiOlduguOteller?: OtelCreateNestedManyWithoutYoneticiInput
  }

  export type MusteriUncheckedCreateInput = {
    id?: number
    ad: string
    soyad: string
    email: string
    telefon: string
    sifre: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    rezervasyonlar?: RezervasyonUncheckedCreateNestedManyWithoutMusteriInput
    yoneticiOlduguOteller?: OtelUncheckedCreateNestedManyWithoutYoneticiInput
  }

  export type MusteriUpdateInput = {
    ad?: StringFieldUpdateOperationsInput | string
    soyad?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefon?: StringFieldUpdateOperationsInput | string
    sifre?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rezervasyonlar?: RezervasyonUpdateManyWithoutMusteriNestedInput
    yoneticiOlduguOteller?: OtelUpdateManyWithoutYoneticiNestedInput
  }

  export type MusteriUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ad?: StringFieldUpdateOperationsInput | string
    soyad?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefon?: StringFieldUpdateOperationsInput | string
    sifre?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rezervasyonlar?: RezervasyonUncheckedUpdateManyWithoutMusteriNestedInput
    yoneticiOlduguOteller?: OtelUncheckedUpdateManyWithoutYoneticiNestedInput
  }

  export type MusteriCreateManyInput = {
    id?: number
    ad: string
    soyad: string
    email: string
    telefon: string
    sifre: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MusteriUpdateManyMutationInput = {
    ad?: StringFieldUpdateOperationsInput | string
    soyad?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefon?: StringFieldUpdateOperationsInput | string
    sifre?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MusteriUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ad?: StringFieldUpdateOperationsInput | string
    soyad?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefon?: StringFieldUpdateOperationsInput | string
    sifre?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtelCreateInput = {
    ad: string
    adres: string
    sehir: string
    yildiz: number
    aciklama?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    yonetici: MusteriCreateNestedOneWithoutYoneticiOlduguOtellerInput
    odalar?: OdaCreateNestedManyWithoutOtelInput
  }

  export type OtelUncheckedCreateInput = {
    id?: number
    ad: string
    adres: string
    sehir: string
    yildiz: number
    aciklama?: string | null
    yoneticiId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    odalar?: OdaUncheckedCreateNestedManyWithoutOtelInput
  }

  export type OtelUpdateInput = {
    ad?: StringFieldUpdateOperationsInput | string
    adres?: StringFieldUpdateOperationsInput | string
    sehir?: StringFieldUpdateOperationsInput | string
    yildiz?: IntFieldUpdateOperationsInput | number
    aciklama?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yonetici?: MusteriUpdateOneRequiredWithoutYoneticiOlduguOtellerNestedInput
    odalar?: OdaUpdateManyWithoutOtelNestedInput
  }

  export type OtelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ad?: StringFieldUpdateOperationsInput | string
    adres?: StringFieldUpdateOperationsInput | string
    sehir?: StringFieldUpdateOperationsInput | string
    yildiz?: IntFieldUpdateOperationsInput | number
    aciklama?: NullableStringFieldUpdateOperationsInput | string | null
    yoneticiId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    odalar?: OdaUncheckedUpdateManyWithoutOtelNestedInput
  }

  export type OtelCreateManyInput = {
    id?: number
    ad: string
    adres: string
    sehir: string
    yildiz: number
    aciklama?: string | null
    yoneticiId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OtelUpdateManyMutationInput = {
    ad?: StringFieldUpdateOperationsInput | string
    adres?: StringFieldUpdateOperationsInput | string
    sehir?: StringFieldUpdateOperationsInput | string
    yildiz?: IntFieldUpdateOperationsInput | number
    aciklama?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ad?: StringFieldUpdateOperationsInput | string
    adres?: StringFieldUpdateOperationsInput | string
    sehir?: StringFieldUpdateOperationsInput | string
    yildiz?: IntFieldUpdateOperationsInput | number
    aciklama?: NullableStringFieldUpdateOperationsInput | string | null
    yoneticiId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OdaCreateInput = {
    numara: string
    tip: string
    fiyat: number
    kapasite: number
    createdAt?: Date | string
    updatedAt?: Date | string
    otel: OtelCreateNestedOneWithoutOdalarInput
    rezervasyonlar?: RezervasyonCreateNestedManyWithoutOdaInput
    durumlar?: OdaDurumuCreateNestedManyWithoutOdaInput
  }

  export type OdaUncheckedCreateInput = {
    id?: number
    numara: string
    tip: string
    fiyat: number
    kapasite: number
    otelId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rezervasyonlar?: RezervasyonUncheckedCreateNestedManyWithoutOdaInput
    durumlar?: OdaDurumuUncheckedCreateNestedManyWithoutOdaInput
  }

  export type OdaUpdateInput = {
    numara?: StringFieldUpdateOperationsInput | string
    tip?: StringFieldUpdateOperationsInput | string
    fiyat?: FloatFieldUpdateOperationsInput | number
    kapasite?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otel?: OtelUpdateOneRequiredWithoutOdalarNestedInput
    rezervasyonlar?: RezervasyonUpdateManyWithoutOdaNestedInput
    durumlar?: OdaDurumuUpdateManyWithoutOdaNestedInput
  }

  export type OdaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    numara?: StringFieldUpdateOperationsInput | string
    tip?: StringFieldUpdateOperationsInput | string
    fiyat?: FloatFieldUpdateOperationsInput | number
    kapasite?: IntFieldUpdateOperationsInput | number
    otelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rezervasyonlar?: RezervasyonUncheckedUpdateManyWithoutOdaNestedInput
    durumlar?: OdaDurumuUncheckedUpdateManyWithoutOdaNestedInput
  }

  export type OdaCreateManyInput = {
    id?: number
    numara: string
    tip: string
    fiyat: number
    kapasite: number
    otelId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OdaUpdateManyMutationInput = {
    numara?: StringFieldUpdateOperationsInput | string
    tip?: StringFieldUpdateOperationsInput | string
    fiyat?: FloatFieldUpdateOperationsInput | number
    kapasite?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OdaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    numara?: StringFieldUpdateOperationsInput | string
    tip?: StringFieldUpdateOperationsInput | string
    fiyat?: FloatFieldUpdateOperationsInput | number
    kapasite?: IntFieldUpdateOperationsInput | number
    otelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RezervasyonCreateInput = {
    girisTarihi: Date | string
    cikisTarihi: Date | string
    toplamFiyat: number
    durum?: $Enums.RezervasyonDurumu
    createdAt?: Date | string
    updatedAt?: Date | string
    musteri: MusteriCreateNestedOneWithoutRezervasyonlarInput
    oda: OdaCreateNestedOneWithoutRezervasyonlarInput
  }

  export type RezervasyonUncheckedCreateInput = {
    id?: number
    musteriId: number
    odaId: number
    girisTarihi: Date | string
    cikisTarihi: Date | string
    toplamFiyat: number
    durum?: $Enums.RezervasyonDurumu
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RezervasyonUpdateInput = {
    girisTarihi?: DateTimeFieldUpdateOperationsInput | Date | string
    cikisTarihi?: DateTimeFieldUpdateOperationsInput | Date | string
    toplamFiyat?: FloatFieldUpdateOperationsInput | number
    durum?: EnumRezervasyonDurumuFieldUpdateOperationsInput | $Enums.RezervasyonDurumu
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    musteri?: MusteriUpdateOneRequiredWithoutRezervasyonlarNestedInput
    oda?: OdaUpdateOneRequiredWithoutRezervasyonlarNestedInput
  }

  export type RezervasyonUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    musteriId?: IntFieldUpdateOperationsInput | number
    odaId?: IntFieldUpdateOperationsInput | number
    girisTarihi?: DateTimeFieldUpdateOperationsInput | Date | string
    cikisTarihi?: DateTimeFieldUpdateOperationsInput | Date | string
    toplamFiyat?: FloatFieldUpdateOperationsInput | number
    durum?: EnumRezervasyonDurumuFieldUpdateOperationsInput | $Enums.RezervasyonDurumu
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RezervasyonCreateManyInput = {
    id?: number
    musteriId: number
    odaId: number
    girisTarihi: Date | string
    cikisTarihi: Date | string
    toplamFiyat: number
    durum?: $Enums.RezervasyonDurumu
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RezervasyonUpdateManyMutationInput = {
    girisTarihi?: DateTimeFieldUpdateOperationsInput | Date | string
    cikisTarihi?: DateTimeFieldUpdateOperationsInput | Date | string
    toplamFiyat?: FloatFieldUpdateOperationsInput | number
    durum?: EnumRezervasyonDurumuFieldUpdateOperationsInput | $Enums.RezervasyonDurumu
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RezervasyonUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    musteriId?: IntFieldUpdateOperationsInput | number
    odaId?: IntFieldUpdateOperationsInput | number
    girisTarihi?: DateTimeFieldUpdateOperationsInput | Date | string
    cikisTarihi?: DateTimeFieldUpdateOperationsInput | Date | string
    toplamFiyat?: FloatFieldUpdateOperationsInput | number
    durum?: EnumRezervasyonDurumuFieldUpdateOperationsInput | $Enums.RezervasyonDurumu
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OdaDurumuCreateInput = {
    tarih: Date | string
    durum: $Enums.OdaDurumTipi
    createdAt?: Date | string
    updatedAt?: Date | string
    oda: OdaCreateNestedOneWithoutDurumlarInput
  }

  export type OdaDurumuUncheckedCreateInput = {
    id?: number
    odaId: number
    tarih: Date | string
    durum: $Enums.OdaDurumTipi
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OdaDurumuUpdateInput = {
    tarih?: DateTimeFieldUpdateOperationsInput | Date | string
    durum?: EnumOdaDurumTipiFieldUpdateOperationsInput | $Enums.OdaDurumTipi
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    oda?: OdaUpdateOneRequiredWithoutDurumlarNestedInput
  }

  export type OdaDurumuUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    odaId?: IntFieldUpdateOperationsInput | number
    tarih?: DateTimeFieldUpdateOperationsInput | Date | string
    durum?: EnumOdaDurumTipiFieldUpdateOperationsInput | $Enums.OdaDurumTipi
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OdaDurumuCreateManyInput = {
    id?: number
    odaId: number
    tarih: Date | string
    durum: $Enums.OdaDurumTipi
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OdaDurumuUpdateManyMutationInput = {
    tarih?: DateTimeFieldUpdateOperationsInput | Date | string
    durum?: EnumOdaDurumTipiFieldUpdateOperationsInput | $Enums.OdaDurumTipi
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OdaDurumuUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    odaId?: IntFieldUpdateOperationsInput | number
    tarih?: DateTimeFieldUpdateOperationsInput | Date | string
    durum?: EnumOdaDurumTipiFieldUpdateOperationsInput | $Enums.OdaDurumTipi
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRolFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[] | ListEnumRolFieldRefInput<$PrismaModel>
    notIn?: $Enums.Rol[] | ListEnumRolFieldRefInput<$PrismaModel>
    not?: NestedEnumRolFilter<$PrismaModel> | $Enums.Rol
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type RezervasyonListRelationFilter = {
    every?: RezervasyonWhereInput
    some?: RezervasyonWhereInput
    none?: RezervasyonWhereInput
  }

  export type OtelListRelationFilter = {
    every?: OtelWhereInput
    some?: OtelWhereInput
    none?: OtelWhereInput
  }

  export type RezervasyonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OtelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MusteriCountOrderByAggregateInput = {
    id?: SortOrder
    ad?: SortOrder
    soyad?: SortOrder
    email?: SortOrder
    telefon?: SortOrder
    sifre?: SortOrder
    rol?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MusteriAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MusteriMaxOrderByAggregateInput = {
    id?: SortOrder
    ad?: SortOrder
    soyad?: SortOrder
    email?: SortOrder
    telefon?: SortOrder
    sifre?: SortOrder
    rol?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MusteriMinOrderByAggregateInput = {
    id?: SortOrder
    ad?: SortOrder
    soyad?: SortOrder
    email?: SortOrder
    telefon?: SortOrder
    sifre?: SortOrder
    rol?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MusteriSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[] | ListEnumRolFieldRefInput<$PrismaModel>
    notIn?: $Enums.Rol[] | ListEnumRolFieldRefInput<$PrismaModel>
    not?: NestedEnumRolWithAggregatesFilter<$PrismaModel> | $Enums.Rol
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolFilter<$PrismaModel>
    _max?: NestedEnumRolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type MusteriRelationFilter = {
    is?: MusteriWhereInput
    isNot?: MusteriWhereInput
  }

  export type OdaListRelationFilter = {
    every?: OdaWhereInput
    some?: OdaWhereInput
    none?: OdaWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type OdaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OtelCountOrderByAggregateInput = {
    id?: SortOrder
    ad?: SortOrder
    adres?: SortOrder
    sehir?: SortOrder
    yildiz?: SortOrder
    aciklama?: SortOrder
    yoneticiId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OtelAvgOrderByAggregateInput = {
    id?: SortOrder
    yildiz?: SortOrder
    yoneticiId?: SortOrder
  }

  export type OtelMaxOrderByAggregateInput = {
    id?: SortOrder
    ad?: SortOrder
    adres?: SortOrder
    sehir?: SortOrder
    yildiz?: SortOrder
    aciklama?: SortOrder
    yoneticiId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OtelMinOrderByAggregateInput = {
    id?: SortOrder
    ad?: SortOrder
    adres?: SortOrder
    sehir?: SortOrder
    yildiz?: SortOrder
    aciklama?: SortOrder
    yoneticiId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OtelSumOrderByAggregateInput = {
    id?: SortOrder
    yildiz?: SortOrder
    yoneticiId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type OtelRelationFilter = {
    is?: OtelWhereInput
    isNot?: OtelWhereInput
  }

  export type OdaDurumuListRelationFilter = {
    every?: OdaDurumuWhereInput
    some?: OdaDurumuWhereInput
    none?: OdaDurumuWhereInput
  }

  export type OdaDurumuOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OdaCountOrderByAggregateInput = {
    id?: SortOrder
    numara?: SortOrder
    tip?: SortOrder
    fiyat?: SortOrder
    kapasite?: SortOrder
    otelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OdaAvgOrderByAggregateInput = {
    id?: SortOrder
    fiyat?: SortOrder
    kapasite?: SortOrder
    otelId?: SortOrder
  }

  export type OdaMaxOrderByAggregateInput = {
    id?: SortOrder
    numara?: SortOrder
    tip?: SortOrder
    fiyat?: SortOrder
    kapasite?: SortOrder
    otelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OdaMinOrderByAggregateInput = {
    id?: SortOrder
    numara?: SortOrder
    tip?: SortOrder
    fiyat?: SortOrder
    kapasite?: SortOrder
    otelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OdaSumOrderByAggregateInput = {
    id?: SortOrder
    fiyat?: SortOrder
    kapasite?: SortOrder
    otelId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumRezervasyonDurumuFilter<$PrismaModel = never> = {
    equals?: $Enums.RezervasyonDurumu | EnumRezervasyonDurumuFieldRefInput<$PrismaModel>
    in?: $Enums.RezervasyonDurumu[] | ListEnumRezervasyonDurumuFieldRefInput<$PrismaModel>
    notIn?: $Enums.RezervasyonDurumu[] | ListEnumRezervasyonDurumuFieldRefInput<$PrismaModel>
    not?: NestedEnumRezervasyonDurumuFilter<$PrismaModel> | $Enums.RezervasyonDurumu
  }

  export type OdaRelationFilter = {
    is?: OdaWhereInput
    isNot?: OdaWhereInput
  }

  export type RezervasyonCountOrderByAggregateInput = {
    id?: SortOrder
    musteriId?: SortOrder
    odaId?: SortOrder
    girisTarihi?: SortOrder
    cikisTarihi?: SortOrder
    toplamFiyat?: SortOrder
    durum?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RezervasyonAvgOrderByAggregateInput = {
    id?: SortOrder
    musteriId?: SortOrder
    odaId?: SortOrder
    toplamFiyat?: SortOrder
  }

  export type RezervasyonMaxOrderByAggregateInput = {
    id?: SortOrder
    musteriId?: SortOrder
    odaId?: SortOrder
    girisTarihi?: SortOrder
    cikisTarihi?: SortOrder
    toplamFiyat?: SortOrder
    durum?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RezervasyonMinOrderByAggregateInput = {
    id?: SortOrder
    musteriId?: SortOrder
    odaId?: SortOrder
    girisTarihi?: SortOrder
    cikisTarihi?: SortOrder
    toplamFiyat?: SortOrder
    durum?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RezervasyonSumOrderByAggregateInput = {
    id?: SortOrder
    musteriId?: SortOrder
    odaId?: SortOrder
    toplamFiyat?: SortOrder
  }

  export type EnumRezervasyonDurumuWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RezervasyonDurumu | EnumRezervasyonDurumuFieldRefInput<$PrismaModel>
    in?: $Enums.RezervasyonDurumu[] | ListEnumRezervasyonDurumuFieldRefInput<$PrismaModel>
    notIn?: $Enums.RezervasyonDurumu[] | ListEnumRezervasyonDurumuFieldRefInput<$PrismaModel>
    not?: NestedEnumRezervasyonDurumuWithAggregatesFilter<$PrismaModel> | $Enums.RezervasyonDurumu
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRezervasyonDurumuFilter<$PrismaModel>
    _max?: NestedEnumRezervasyonDurumuFilter<$PrismaModel>
  }

  export type EnumOdaDurumTipiFilter<$PrismaModel = never> = {
    equals?: $Enums.OdaDurumTipi | EnumOdaDurumTipiFieldRefInput<$PrismaModel>
    in?: $Enums.OdaDurumTipi[] | ListEnumOdaDurumTipiFieldRefInput<$PrismaModel>
    notIn?: $Enums.OdaDurumTipi[] | ListEnumOdaDurumTipiFieldRefInput<$PrismaModel>
    not?: NestedEnumOdaDurumTipiFilter<$PrismaModel> | $Enums.OdaDurumTipi
  }

  export type OdaDurumuOdaIdTarihCompoundUniqueInput = {
    odaId: number
    tarih: Date | string
  }

  export type OdaDurumuCountOrderByAggregateInput = {
    id?: SortOrder
    odaId?: SortOrder
    tarih?: SortOrder
    durum?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OdaDurumuAvgOrderByAggregateInput = {
    id?: SortOrder
    odaId?: SortOrder
  }

  export type OdaDurumuMaxOrderByAggregateInput = {
    id?: SortOrder
    odaId?: SortOrder
    tarih?: SortOrder
    durum?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OdaDurumuMinOrderByAggregateInput = {
    id?: SortOrder
    odaId?: SortOrder
    tarih?: SortOrder
    durum?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OdaDurumuSumOrderByAggregateInput = {
    id?: SortOrder
    odaId?: SortOrder
  }

  export type EnumOdaDurumTipiWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OdaDurumTipi | EnumOdaDurumTipiFieldRefInput<$PrismaModel>
    in?: $Enums.OdaDurumTipi[] | ListEnumOdaDurumTipiFieldRefInput<$PrismaModel>
    notIn?: $Enums.OdaDurumTipi[] | ListEnumOdaDurumTipiFieldRefInput<$PrismaModel>
    not?: NestedEnumOdaDurumTipiWithAggregatesFilter<$PrismaModel> | $Enums.OdaDurumTipi
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOdaDurumTipiFilter<$PrismaModel>
    _max?: NestedEnumOdaDurumTipiFilter<$PrismaModel>
  }

  export type RezervasyonCreateNestedManyWithoutMusteriInput = {
    create?: XOR<RezervasyonCreateWithoutMusteriInput, RezervasyonUncheckedCreateWithoutMusteriInput> | RezervasyonCreateWithoutMusteriInput[] | RezervasyonUncheckedCreateWithoutMusteriInput[]
    connectOrCreate?: RezervasyonCreateOrConnectWithoutMusteriInput | RezervasyonCreateOrConnectWithoutMusteriInput[]
    createMany?: RezervasyonCreateManyMusteriInputEnvelope
    connect?: RezervasyonWhereUniqueInput | RezervasyonWhereUniqueInput[]
  }

  export type OtelCreateNestedManyWithoutYoneticiInput = {
    create?: XOR<OtelCreateWithoutYoneticiInput, OtelUncheckedCreateWithoutYoneticiInput> | OtelCreateWithoutYoneticiInput[] | OtelUncheckedCreateWithoutYoneticiInput[]
    connectOrCreate?: OtelCreateOrConnectWithoutYoneticiInput | OtelCreateOrConnectWithoutYoneticiInput[]
    createMany?: OtelCreateManyYoneticiInputEnvelope
    connect?: OtelWhereUniqueInput | OtelWhereUniqueInput[]
  }

  export type RezervasyonUncheckedCreateNestedManyWithoutMusteriInput = {
    create?: XOR<RezervasyonCreateWithoutMusteriInput, RezervasyonUncheckedCreateWithoutMusteriInput> | RezervasyonCreateWithoutMusteriInput[] | RezervasyonUncheckedCreateWithoutMusteriInput[]
    connectOrCreate?: RezervasyonCreateOrConnectWithoutMusteriInput | RezervasyonCreateOrConnectWithoutMusteriInput[]
    createMany?: RezervasyonCreateManyMusteriInputEnvelope
    connect?: RezervasyonWhereUniqueInput | RezervasyonWhereUniqueInput[]
  }

  export type OtelUncheckedCreateNestedManyWithoutYoneticiInput = {
    create?: XOR<OtelCreateWithoutYoneticiInput, OtelUncheckedCreateWithoutYoneticiInput> | OtelCreateWithoutYoneticiInput[] | OtelUncheckedCreateWithoutYoneticiInput[]
    connectOrCreate?: OtelCreateOrConnectWithoutYoneticiInput | OtelCreateOrConnectWithoutYoneticiInput[]
    createMany?: OtelCreateManyYoneticiInputEnvelope
    connect?: OtelWhereUniqueInput | OtelWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRolFieldUpdateOperationsInput = {
    set?: $Enums.Rol
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type RezervasyonUpdateManyWithoutMusteriNestedInput = {
    create?: XOR<RezervasyonCreateWithoutMusteriInput, RezervasyonUncheckedCreateWithoutMusteriInput> | RezervasyonCreateWithoutMusteriInput[] | RezervasyonUncheckedCreateWithoutMusteriInput[]
    connectOrCreate?: RezervasyonCreateOrConnectWithoutMusteriInput | RezervasyonCreateOrConnectWithoutMusteriInput[]
    upsert?: RezervasyonUpsertWithWhereUniqueWithoutMusteriInput | RezervasyonUpsertWithWhereUniqueWithoutMusteriInput[]
    createMany?: RezervasyonCreateManyMusteriInputEnvelope
    set?: RezervasyonWhereUniqueInput | RezervasyonWhereUniqueInput[]
    disconnect?: RezervasyonWhereUniqueInput | RezervasyonWhereUniqueInput[]
    delete?: RezervasyonWhereUniqueInput | RezervasyonWhereUniqueInput[]
    connect?: RezervasyonWhereUniqueInput | RezervasyonWhereUniqueInput[]
    update?: RezervasyonUpdateWithWhereUniqueWithoutMusteriInput | RezervasyonUpdateWithWhereUniqueWithoutMusteriInput[]
    updateMany?: RezervasyonUpdateManyWithWhereWithoutMusteriInput | RezervasyonUpdateManyWithWhereWithoutMusteriInput[]
    deleteMany?: RezervasyonScalarWhereInput | RezervasyonScalarWhereInput[]
  }

  export type OtelUpdateManyWithoutYoneticiNestedInput = {
    create?: XOR<OtelCreateWithoutYoneticiInput, OtelUncheckedCreateWithoutYoneticiInput> | OtelCreateWithoutYoneticiInput[] | OtelUncheckedCreateWithoutYoneticiInput[]
    connectOrCreate?: OtelCreateOrConnectWithoutYoneticiInput | OtelCreateOrConnectWithoutYoneticiInput[]
    upsert?: OtelUpsertWithWhereUniqueWithoutYoneticiInput | OtelUpsertWithWhereUniqueWithoutYoneticiInput[]
    createMany?: OtelCreateManyYoneticiInputEnvelope
    set?: OtelWhereUniqueInput | OtelWhereUniqueInput[]
    disconnect?: OtelWhereUniqueInput | OtelWhereUniqueInput[]
    delete?: OtelWhereUniqueInput | OtelWhereUniqueInput[]
    connect?: OtelWhereUniqueInput | OtelWhereUniqueInput[]
    update?: OtelUpdateWithWhereUniqueWithoutYoneticiInput | OtelUpdateWithWhereUniqueWithoutYoneticiInput[]
    updateMany?: OtelUpdateManyWithWhereWithoutYoneticiInput | OtelUpdateManyWithWhereWithoutYoneticiInput[]
    deleteMany?: OtelScalarWhereInput | OtelScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RezervasyonUncheckedUpdateManyWithoutMusteriNestedInput = {
    create?: XOR<RezervasyonCreateWithoutMusteriInput, RezervasyonUncheckedCreateWithoutMusteriInput> | RezervasyonCreateWithoutMusteriInput[] | RezervasyonUncheckedCreateWithoutMusteriInput[]
    connectOrCreate?: RezervasyonCreateOrConnectWithoutMusteriInput | RezervasyonCreateOrConnectWithoutMusteriInput[]
    upsert?: RezervasyonUpsertWithWhereUniqueWithoutMusteriInput | RezervasyonUpsertWithWhereUniqueWithoutMusteriInput[]
    createMany?: RezervasyonCreateManyMusteriInputEnvelope
    set?: RezervasyonWhereUniqueInput | RezervasyonWhereUniqueInput[]
    disconnect?: RezervasyonWhereUniqueInput | RezervasyonWhereUniqueInput[]
    delete?: RezervasyonWhereUniqueInput | RezervasyonWhereUniqueInput[]
    connect?: RezervasyonWhereUniqueInput | RezervasyonWhereUniqueInput[]
    update?: RezervasyonUpdateWithWhereUniqueWithoutMusteriInput | RezervasyonUpdateWithWhereUniqueWithoutMusteriInput[]
    updateMany?: RezervasyonUpdateManyWithWhereWithoutMusteriInput | RezervasyonUpdateManyWithWhereWithoutMusteriInput[]
    deleteMany?: RezervasyonScalarWhereInput | RezervasyonScalarWhereInput[]
  }

  export type OtelUncheckedUpdateManyWithoutYoneticiNestedInput = {
    create?: XOR<OtelCreateWithoutYoneticiInput, OtelUncheckedCreateWithoutYoneticiInput> | OtelCreateWithoutYoneticiInput[] | OtelUncheckedCreateWithoutYoneticiInput[]
    connectOrCreate?: OtelCreateOrConnectWithoutYoneticiInput | OtelCreateOrConnectWithoutYoneticiInput[]
    upsert?: OtelUpsertWithWhereUniqueWithoutYoneticiInput | OtelUpsertWithWhereUniqueWithoutYoneticiInput[]
    createMany?: OtelCreateManyYoneticiInputEnvelope
    set?: OtelWhereUniqueInput | OtelWhereUniqueInput[]
    disconnect?: OtelWhereUniqueInput | OtelWhereUniqueInput[]
    delete?: OtelWhereUniqueInput | OtelWhereUniqueInput[]
    connect?: OtelWhereUniqueInput | OtelWhereUniqueInput[]
    update?: OtelUpdateWithWhereUniqueWithoutYoneticiInput | OtelUpdateWithWhereUniqueWithoutYoneticiInput[]
    updateMany?: OtelUpdateManyWithWhereWithoutYoneticiInput | OtelUpdateManyWithWhereWithoutYoneticiInput[]
    deleteMany?: OtelScalarWhereInput | OtelScalarWhereInput[]
  }

  export type MusteriCreateNestedOneWithoutYoneticiOlduguOtellerInput = {
    create?: XOR<MusteriCreateWithoutYoneticiOlduguOtellerInput, MusteriUncheckedCreateWithoutYoneticiOlduguOtellerInput>
    connectOrCreate?: MusteriCreateOrConnectWithoutYoneticiOlduguOtellerInput
    connect?: MusteriWhereUniqueInput
  }

  export type OdaCreateNestedManyWithoutOtelInput = {
    create?: XOR<OdaCreateWithoutOtelInput, OdaUncheckedCreateWithoutOtelInput> | OdaCreateWithoutOtelInput[] | OdaUncheckedCreateWithoutOtelInput[]
    connectOrCreate?: OdaCreateOrConnectWithoutOtelInput | OdaCreateOrConnectWithoutOtelInput[]
    createMany?: OdaCreateManyOtelInputEnvelope
    connect?: OdaWhereUniqueInput | OdaWhereUniqueInput[]
  }

  export type OdaUncheckedCreateNestedManyWithoutOtelInput = {
    create?: XOR<OdaCreateWithoutOtelInput, OdaUncheckedCreateWithoutOtelInput> | OdaCreateWithoutOtelInput[] | OdaUncheckedCreateWithoutOtelInput[]
    connectOrCreate?: OdaCreateOrConnectWithoutOtelInput | OdaCreateOrConnectWithoutOtelInput[]
    createMany?: OdaCreateManyOtelInputEnvelope
    connect?: OdaWhereUniqueInput | OdaWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type MusteriUpdateOneRequiredWithoutYoneticiOlduguOtellerNestedInput = {
    create?: XOR<MusteriCreateWithoutYoneticiOlduguOtellerInput, MusteriUncheckedCreateWithoutYoneticiOlduguOtellerInput>
    connectOrCreate?: MusteriCreateOrConnectWithoutYoneticiOlduguOtellerInput
    upsert?: MusteriUpsertWithoutYoneticiOlduguOtellerInput
    connect?: MusteriWhereUniqueInput
    update?: XOR<XOR<MusteriUpdateToOneWithWhereWithoutYoneticiOlduguOtellerInput, MusteriUpdateWithoutYoneticiOlduguOtellerInput>, MusteriUncheckedUpdateWithoutYoneticiOlduguOtellerInput>
  }

  export type OdaUpdateManyWithoutOtelNestedInput = {
    create?: XOR<OdaCreateWithoutOtelInput, OdaUncheckedCreateWithoutOtelInput> | OdaCreateWithoutOtelInput[] | OdaUncheckedCreateWithoutOtelInput[]
    connectOrCreate?: OdaCreateOrConnectWithoutOtelInput | OdaCreateOrConnectWithoutOtelInput[]
    upsert?: OdaUpsertWithWhereUniqueWithoutOtelInput | OdaUpsertWithWhereUniqueWithoutOtelInput[]
    createMany?: OdaCreateManyOtelInputEnvelope
    set?: OdaWhereUniqueInput | OdaWhereUniqueInput[]
    disconnect?: OdaWhereUniqueInput | OdaWhereUniqueInput[]
    delete?: OdaWhereUniqueInput | OdaWhereUniqueInput[]
    connect?: OdaWhereUniqueInput | OdaWhereUniqueInput[]
    update?: OdaUpdateWithWhereUniqueWithoutOtelInput | OdaUpdateWithWhereUniqueWithoutOtelInput[]
    updateMany?: OdaUpdateManyWithWhereWithoutOtelInput | OdaUpdateManyWithWhereWithoutOtelInput[]
    deleteMany?: OdaScalarWhereInput | OdaScalarWhereInput[]
  }

  export type OdaUncheckedUpdateManyWithoutOtelNestedInput = {
    create?: XOR<OdaCreateWithoutOtelInput, OdaUncheckedCreateWithoutOtelInput> | OdaCreateWithoutOtelInput[] | OdaUncheckedCreateWithoutOtelInput[]
    connectOrCreate?: OdaCreateOrConnectWithoutOtelInput | OdaCreateOrConnectWithoutOtelInput[]
    upsert?: OdaUpsertWithWhereUniqueWithoutOtelInput | OdaUpsertWithWhereUniqueWithoutOtelInput[]
    createMany?: OdaCreateManyOtelInputEnvelope
    set?: OdaWhereUniqueInput | OdaWhereUniqueInput[]
    disconnect?: OdaWhereUniqueInput | OdaWhereUniqueInput[]
    delete?: OdaWhereUniqueInput | OdaWhereUniqueInput[]
    connect?: OdaWhereUniqueInput | OdaWhereUniqueInput[]
    update?: OdaUpdateWithWhereUniqueWithoutOtelInput | OdaUpdateWithWhereUniqueWithoutOtelInput[]
    updateMany?: OdaUpdateManyWithWhereWithoutOtelInput | OdaUpdateManyWithWhereWithoutOtelInput[]
    deleteMany?: OdaScalarWhereInput | OdaScalarWhereInput[]
  }

  export type OtelCreateNestedOneWithoutOdalarInput = {
    create?: XOR<OtelCreateWithoutOdalarInput, OtelUncheckedCreateWithoutOdalarInput>
    connectOrCreate?: OtelCreateOrConnectWithoutOdalarInput
    connect?: OtelWhereUniqueInput
  }

  export type RezervasyonCreateNestedManyWithoutOdaInput = {
    create?: XOR<RezervasyonCreateWithoutOdaInput, RezervasyonUncheckedCreateWithoutOdaInput> | RezervasyonCreateWithoutOdaInput[] | RezervasyonUncheckedCreateWithoutOdaInput[]
    connectOrCreate?: RezervasyonCreateOrConnectWithoutOdaInput | RezervasyonCreateOrConnectWithoutOdaInput[]
    createMany?: RezervasyonCreateManyOdaInputEnvelope
    connect?: RezervasyonWhereUniqueInput | RezervasyonWhereUniqueInput[]
  }

  export type OdaDurumuCreateNestedManyWithoutOdaInput = {
    create?: XOR<OdaDurumuCreateWithoutOdaInput, OdaDurumuUncheckedCreateWithoutOdaInput> | OdaDurumuCreateWithoutOdaInput[] | OdaDurumuUncheckedCreateWithoutOdaInput[]
    connectOrCreate?: OdaDurumuCreateOrConnectWithoutOdaInput | OdaDurumuCreateOrConnectWithoutOdaInput[]
    createMany?: OdaDurumuCreateManyOdaInputEnvelope
    connect?: OdaDurumuWhereUniqueInput | OdaDurumuWhereUniqueInput[]
  }

  export type RezervasyonUncheckedCreateNestedManyWithoutOdaInput = {
    create?: XOR<RezervasyonCreateWithoutOdaInput, RezervasyonUncheckedCreateWithoutOdaInput> | RezervasyonCreateWithoutOdaInput[] | RezervasyonUncheckedCreateWithoutOdaInput[]
    connectOrCreate?: RezervasyonCreateOrConnectWithoutOdaInput | RezervasyonCreateOrConnectWithoutOdaInput[]
    createMany?: RezervasyonCreateManyOdaInputEnvelope
    connect?: RezervasyonWhereUniqueInput | RezervasyonWhereUniqueInput[]
  }

  export type OdaDurumuUncheckedCreateNestedManyWithoutOdaInput = {
    create?: XOR<OdaDurumuCreateWithoutOdaInput, OdaDurumuUncheckedCreateWithoutOdaInput> | OdaDurumuCreateWithoutOdaInput[] | OdaDurumuUncheckedCreateWithoutOdaInput[]
    connectOrCreate?: OdaDurumuCreateOrConnectWithoutOdaInput | OdaDurumuCreateOrConnectWithoutOdaInput[]
    createMany?: OdaDurumuCreateManyOdaInputEnvelope
    connect?: OdaDurumuWhereUniqueInput | OdaDurumuWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OtelUpdateOneRequiredWithoutOdalarNestedInput = {
    create?: XOR<OtelCreateWithoutOdalarInput, OtelUncheckedCreateWithoutOdalarInput>
    connectOrCreate?: OtelCreateOrConnectWithoutOdalarInput
    upsert?: OtelUpsertWithoutOdalarInput
    connect?: OtelWhereUniqueInput
    update?: XOR<XOR<OtelUpdateToOneWithWhereWithoutOdalarInput, OtelUpdateWithoutOdalarInput>, OtelUncheckedUpdateWithoutOdalarInput>
  }

  export type RezervasyonUpdateManyWithoutOdaNestedInput = {
    create?: XOR<RezervasyonCreateWithoutOdaInput, RezervasyonUncheckedCreateWithoutOdaInput> | RezervasyonCreateWithoutOdaInput[] | RezervasyonUncheckedCreateWithoutOdaInput[]
    connectOrCreate?: RezervasyonCreateOrConnectWithoutOdaInput | RezervasyonCreateOrConnectWithoutOdaInput[]
    upsert?: RezervasyonUpsertWithWhereUniqueWithoutOdaInput | RezervasyonUpsertWithWhereUniqueWithoutOdaInput[]
    createMany?: RezervasyonCreateManyOdaInputEnvelope
    set?: RezervasyonWhereUniqueInput | RezervasyonWhereUniqueInput[]
    disconnect?: RezervasyonWhereUniqueInput | RezervasyonWhereUniqueInput[]
    delete?: RezervasyonWhereUniqueInput | RezervasyonWhereUniqueInput[]
    connect?: RezervasyonWhereUniqueInput | RezervasyonWhereUniqueInput[]
    update?: RezervasyonUpdateWithWhereUniqueWithoutOdaInput | RezervasyonUpdateWithWhereUniqueWithoutOdaInput[]
    updateMany?: RezervasyonUpdateManyWithWhereWithoutOdaInput | RezervasyonUpdateManyWithWhereWithoutOdaInput[]
    deleteMany?: RezervasyonScalarWhereInput | RezervasyonScalarWhereInput[]
  }

  export type OdaDurumuUpdateManyWithoutOdaNestedInput = {
    create?: XOR<OdaDurumuCreateWithoutOdaInput, OdaDurumuUncheckedCreateWithoutOdaInput> | OdaDurumuCreateWithoutOdaInput[] | OdaDurumuUncheckedCreateWithoutOdaInput[]
    connectOrCreate?: OdaDurumuCreateOrConnectWithoutOdaInput | OdaDurumuCreateOrConnectWithoutOdaInput[]
    upsert?: OdaDurumuUpsertWithWhereUniqueWithoutOdaInput | OdaDurumuUpsertWithWhereUniqueWithoutOdaInput[]
    createMany?: OdaDurumuCreateManyOdaInputEnvelope
    set?: OdaDurumuWhereUniqueInput | OdaDurumuWhereUniqueInput[]
    disconnect?: OdaDurumuWhereUniqueInput | OdaDurumuWhereUniqueInput[]
    delete?: OdaDurumuWhereUniqueInput | OdaDurumuWhereUniqueInput[]
    connect?: OdaDurumuWhereUniqueInput | OdaDurumuWhereUniqueInput[]
    update?: OdaDurumuUpdateWithWhereUniqueWithoutOdaInput | OdaDurumuUpdateWithWhereUniqueWithoutOdaInput[]
    updateMany?: OdaDurumuUpdateManyWithWhereWithoutOdaInput | OdaDurumuUpdateManyWithWhereWithoutOdaInput[]
    deleteMany?: OdaDurumuScalarWhereInput | OdaDurumuScalarWhereInput[]
  }

  export type RezervasyonUncheckedUpdateManyWithoutOdaNestedInput = {
    create?: XOR<RezervasyonCreateWithoutOdaInput, RezervasyonUncheckedCreateWithoutOdaInput> | RezervasyonCreateWithoutOdaInput[] | RezervasyonUncheckedCreateWithoutOdaInput[]
    connectOrCreate?: RezervasyonCreateOrConnectWithoutOdaInput | RezervasyonCreateOrConnectWithoutOdaInput[]
    upsert?: RezervasyonUpsertWithWhereUniqueWithoutOdaInput | RezervasyonUpsertWithWhereUniqueWithoutOdaInput[]
    createMany?: RezervasyonCreateManyOdaInputEnvelope
    set?: RezervasyonWhereUniqueInput | RezervasyonWhereUniqueInput[]
    disconnect?: RezervasyonWhereUniqueInput | RezervasyonWhereUniqueInput[]
    delete?: RezervasyonWhereUniqueInput | RezervasyonWhereUniqueInput[]
    connect?: RezervasyonWhereUniqueInput | RezervasyonWhereUniqueInput[]
    update?: RezervasyonUpdateWithWhereUniqueWithoutOdaInput | RezervasyonUpdateWithWhereUniqueWithoutOdaInput[]
    updateMany?: RezervasyonUpdateManyWithWhereWithoutOdaInput | RezervasyonUpdateManyWithWhereWithoutOdaInput[]
    deleteMany?: RezervasyonScalarWhereInput | RezervasyonScalarWhereInput[]
  }

  export type OdaDurumuUncheckedUpdateManyWithoutOdaNestedInput = {
    create?: XOR<OdaDurumuCreateWithoutOdaInput, OdaDurumuUncheckedCreateWithoutOdaInput> | OdaDurumuCreateWithoutOdaInput[] | OdaDurumuUncheckedCreateWithoutOdaInput[]
    connectOrCreate?: OdaDurumuCreateOrConnectWithoutOdaInput | OdaDurumuCreateOrConnectWithoutOdaInput[]
    upsert?: OdaDurumuUpsertWithWhereUniqueWithoutOdaInput | OdaDurumuUpsertWithWhereUniqueWithoutOdaInput[]
    createMany?: OdaDurumuCreateManyOdaInputEnvelope
    set?: OdaDurumuWhereUniqueInput | OdaDurumuWhereUniqueInput[]
    disconnect?: OdaDurumuWhereUniqueInput | OdaDurumuWhereUniqueInput[]
    delete?: OdaDurumuWhereUniqueInput | OdaDurumuWhereUniqueInput[]
    connect?: OdaDurumuWhereUniqueInput | OdaDurumuWhereUniqueInput[]
    update?: OdaDurumuUpdateWithWhereUniqueWithoutOdaInput | OdaDurumuUpdateWithWhereUniqueWithoutOdaInput[]
    updateMany?: OdaDurumuUpdateManyWithWhereWithoutOdaInput | OdaDurumuUpdateManyWithWhereWithoutOdaInput[]
    deleteMany?: OdaDurumuScalarWhereInput | OdaDurumuScalarWhereInput[]
  }

  export type MusteriCreateNestedOneWithoutRezervasyonlarInput = {
    create?: XOR<MusteriCreateWithoutRezervasyonlarInput, MusteriUncheckedCreateWithoutRezervasyonlarInput>
    connectOrCreate?: MusteriCreateOrConnectWithoutRezervasyonlarInput
    connect?: MusteriWhereUniqueInput
  }

  export type OdaCreateNestedOneWithoutRezervasyonlarInput = {
    create?: XOR<OdaCreateWithoutRezervasyonlarInput, OdaUncheckedCreateWithoutRezervasyonlarInput>
    connectOrCreate?: OdaCreateOrConnectWithoutRezervasyonlarInput
    connect?: OdaWhereUniqueInput
  }

  export type EnumRezervasyonDurumuFieldUpdateOperationsInput = {
    set?: $Enums.RezervasyonDurumu
  }

  export type MusteriUpdateOneRequiredWithoutRezervasyonlarNestedInput = {
    create?: XOR<MusteriCreateWithoutRezervasyonlarInput, MusteriUncheckedCreateWithoutRezervasyonlarInput>
    connectOrCreate?: MusteriCreateOrConnectWithoutRezervasyonlarInput
    upsert?: MusteriUpsertWithoutRezervasyonlarInput
    connect?: MusteriWhereUniqueInput
    update?: XOR<XOR<MusteriUpdateToOneWithWhereWithoutRezervasyonlarInput, MusteriUpdateWithoutRezervasyonlarInput>, MusteriUncheckedUpdateWithoutRezervasyonlarInput>
  }

  export type OdaUpdateOneRequiredWithoutRezervasyonlarNestedInput = {
    create?: XOR<OdaCreateWithoutRezervasyonlarInput, OdaUncheckedCreateWithoutRezervasyonlarInput>
    connectOrCreate?: OdaCreateOrConnectWithoutRezervasyonlarInput
    upsert?: OdaUpsertWithoutRezervasyonlarInput
    connect?: OdaWhereUniqueInput
    update?: XOR<XOR<OdaUpdateToOneWithWhereWithoutRezervasyonlarInput, OdaUpdateWithoutRezervasyonlarInput>, OdaUncheckedUpdateWithoutRezervasyonlarInput>
  }

  export type OdaCreateNestedOneWithoutDurumlarInput = {
    create?: XOR<OdaCreateWithoutDurumlarInput, OdaUncheckedCreateWithoutDurumlarInput>
    connectOrCreate?: OdaCreateOrConnectWithoutDurumlarInput
    connect?: OdaWhereUniqueInput
  }

  export type EnumOdaDurumTipiFieldUpdateOperationsInput = {
    set?: $Enums.OdaDurumTipi
  }

  export type OdaUpdateOneRequiredWithoutDurumlarNestedInput = {
    create?: XOR<OdaCreateWithoutDurumlarInput, OdaUncheckedCreateWithoutDurumlarInput>
    connectOrCreate?: OdaCreateOrConnectWithoutDurumlarInput
    upsert?: OdaUpsertWithoutDurumlarInput
    connect?: OdaWhereUniqueInput
    update?: XOR<XOR<OdaUpdateToOneWithWhereWithoutDurumlarInput, OdaUpdateWithoutDurumlarInput>, OdaUncheckedUpdateWithoutDurumlarInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRolFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[] | ListEnumRolFieldRefInput<$PrismaModel>
    notIn?: $Enums.Rol[] | ListEnumRolFieldRefInput<$PrismaModel>
    not?: NestedEnumRolFilter<$PrismaModel> | $Enums.Rol
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumRolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[] | ListEnumRolFieldRefInput<$PrismaModel>
    notIn?: $Enums.Rol[] | ListEnumRolFieldRefInput<$PrismaModel>
    not?: NestedEnumRolWithAggregatesFilter<$PrismaModel> | $Enums.Rol
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolFilter<$PrismaModel>
    _max?: NestedEnumRolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumRezervasyonDurumuFilter<$PrismaModel = never> = {
    equals?: $Enums.RezervasyonDurumu | EnumRezervasyonDurumuFieldRefInput<$PrismaModel>
    in?: $Enums.RezervasyonDurumu[] | ListEnumRezervasyonDurumuFieldRefInput<$PrismaModel>
    notIn?: $Enums.RezervasyonDurumu[] | ListEnumRezervasyonDurumuFieldRefInput<$PrismaModel>
    not?: NestedEnumRezervasyonDurumuFilter<$PrismaModel> | $Enums.RezervasyonDurumu
  }

  export type NestedEnumRezervasyonDurumuWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RezervasyonDurumu | EnumRezervasyonDurumuFieldRefInput<$PrismaModel>
    in?: $Enums.RezervasyonDurumu[] | ListEnumRezervasyonDurumuFieldRefInput<$PrismaModel>
    notIn?: $Enums.RezervasyonDurumu[] | ListEnumRezervasyonDurumuFieldRefInput<$PrismaModel>
    not?: NestedEnumRezervasyonDurumuWithAggregatesFilter<$PrismaModel> | $Enums.RezervasyonDurumu
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRezervasyonDurumuFilter<$PrismaModel>
    _max?: NestedEnumRezervasyonDurumuFilter<$PrismaModel>
  }

  export type NestedEnumOdaDurumTipiFilter<$PrismaModel = never> = {
    equals?: $Enums.OdaDurumTipi | EnumOdaDurumTipiFieldRefInput<$PrismaModel>
    in?: $Enums.OdaDurumTipi[] | ListEnumOdaDurumTipiFieldRefInput<$PrismaModel>
    notIn?: $Enums.OdaDurumTipi[] | ListEnumOdaDurumTipiFieldRefInput<$PrismaModel>
    not?: NestedEnumOdaDurumTipiFilter<$PrismaModel> | $Enums.OdaDurumTipi
  }

  export type NestedEnumOdaDurumTipiWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OdaDurumTipi | EnumOdaDurumTipiFieldRefInput<$PrismaModel>
    in?: $Enums.OdaDurumTipi[] | ListEnumOdaDurumTipiFieldRefInput<$PrismaModel>
    notIn?: $Enums.OdaDurumTipi[] | ListEnumOdaDurumTipiFieldRefInput<$PrismaModel>
    not?: NestedEnumOdaDurumTipiWithAggregatesFilter<$PrismaModel> | $Enums.OdaDurumTipi
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOdaDurumTipiFilter<$PrismaModel>
    _max?: NestedEnumOdaDurumTipiFilter<$PrismaModel>
  }

  export type RezervasyonCreateWithoutMusteriInput = {
    girisTarihi: Date | string
    cikisTarihi: Date | string
    toplamFiyat: number
    durum?: $Enums.RezervasyonDurumu
    createdAt?: Date | string
    updatedAt?: Date | string
    oda: OdaCreateNestedOneWithoutRezervasyonlarInput
  }

  export type RezervasyonUncheckedCreateWithoutMusteriInput = {
    id?: number
    odaId: number
    girisTarihi: Date | string
    cikisTarihi: Date | string
    toplamFiyat: number
    durum?: $Enums.RezervasyonDurumu
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RezervasyonCreateOrConnectWithoutMusteriInput = {
    where: RezervasyonWhereUniqueInput
    create: XOR<RezervasyonCreateWithoutMusteriInput, RezervasyonUncheckedCreateWithoutMusteriInput>
  }

  export type RezervasyonCreateManyMusteriInputEnvelope = {
    data: RezervasyonCreateManyMusteriInput | RezervasyonCreateManyMusteriInput[]
    skipDuplicates?: boolean
  }

  export type OtelCreateWithoutYoneticiInput = {
    ad: string
    adres: string
    sehir: string
    yildiz: number
    aciklama?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    odalar?: OdaCreateNestedManyWithoutOtelInput
  }

  export type OtelUncheckedCreateWithoutYoneticiInput = {
    id?: number
    ad: string
    adres: string
    sehir: string
    yildiz: number
    aciklama?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    odalar?: OdaUncheckedCreateNestedManyWithoutOtelInput
  }

  export type OtelCreateOrConnectWithoutYoneticiInput = {
    where: OtelWhereUniqueInput
    create: XOR<OtelCreateWithoutYoneticiInput, OtelUncheckedCreateWithoutYoneticiInput>
  }

  export type OtelCreateManyYoneticiInputEnvelope = {
    data: OtelCreateManyYoneticiInput | OtelCreateManyYoneticiInput[]
    skipDuplicates?: boolean
  }

  export type RezervasyonUpsertWithWhereUniqueWithoutMusteriInput = {
    where: RezervasyonWhereUniqueInput
    update: XOR<RezervasyonUpdateWithoutMusteriInput, RezervasyonUncheckedUpdateWithoutMusteriInput>
    create: XOR<RezervasyonCreateWithoutMusteriInput, RezervasyonUncheckedCreateWithoutMusteriInput>
  }

  export type RezervasyonUpdateWithWhereUniqueWithoutMusteriInput = {
    where: RezervasyonWhereUniqueInput
    data: XOR<RezervasyonUpdateWithoutMusteriInput, RezervasyonUncheckedUpdateWithoutMusteriInput>
  }

  export type RezervasyonUpdateManyWithWhereWithoutMusteriInput = {
    where: RezervasyonScalarWhereInput
    data: XOR<RezervasyonUpdateManyMutationInput, RezervasyonUncheckedUpdateManyWithoutMusteriInput>
  }

  export type RezervasyonScalarWhereInput = {
    AND?: RezervasyonScalarWhereInput | RezervasyonScalarWhereInput[]
    OR?: RezervasyonScalarWhereInput[]
    NOT?: RezervasyonScalarWhereInput | RezervasyonScalarWhereInput[]
    id?: IntFilter<"Rezervasyon"> | number
    musteriId?: IntFilter<"Rezervasyon"> | number
    odaId?: IntFilter<"Rezervasyon"> | number
    girisTarihi?: DateTimeFilter<"Rezervasyon"> | Date | string
    cikisTarihi?: DateTimeFilter<"Rezervasyon"> | Date | string
    toplamFiyat?: FloatFilter<"Rezervasyon"> | number
    durum?: EnumRezervasyonDurumuFilter<"Rezervasyon"> | $Enums.RezervasyonDurumu
    createdAt?: DateTimeFilter<"Rezervasyon"> | Date | string
    updatedAt?: DateTimeFilter<"Rezervasyon"> | Date | string
  }

  export type OtelUpsertWithWhereUniqueWithoutYoneticiInput = {
    where: OtelWhereUniqueInput
    update: XOR<OtelUpdateWithoutYoneticiInput, OtelUncheckedUpdateWithoutYoneticiInput>
    create: XOR<OtelCreateWithoutYoneticiInput, OtelUncheckedCreateWithoutYoneticiInput>
  }

  export type OtelUpdateWithWhereUniqueWithoutYoneticiInput = {
    where: OtelWhereUniqueInput
    data: XOR<OtelUpdateWithoutYoneticiInput, OtelUncheckedUpdateWithoutYoneticiInput>
  }

  export type OtelUpdateManyWithWhereWithoutYoneticiInput = {
    where: OtelScalarWhereInput
    data: XOR<OtelUpdateManyMutationInput, OtelUncheckedUpdateManyWithoutYoneticiInput>
  }

  export type OtelScalarWhereInput = {
    AND?: OtelScalarWhereInput | OtelScalarWhereInput[]
    OR?: OtelScalarWhereInput[]
    NOT?: OtelScalarWhereInput | OtelScalarWhereInput[]
    id?: IntFilter<"Otel"> | number
    ad?: StringFilter<"Otel"> | string
    adres?: StringFilter<"Otel"> | string
    sehir?: StringFilter<"Otel"> | string
    yildiz?: IntFilter<"Otel"> | number
    aciklama?: StringNullableFilter<"Otel"> | string | null
    yoneticiId?: IntFilter<"Otel"> | number
    createdAt?: DateTimeFilter<"Otel"> | Date | string
    updatedAt?: DateTimeFilter<"Otel"> | Date | string
  }

  export type MusteriCreateWithoutYoneticiOlduguOtellerInput = {
    ad: string
    soyad: string
    email: string
    telefon: string
    sifre: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    rezervasyonlar?: RezervasyonCreateNestedManyWithoutMusteriInput
  }

  export type MusteriUncheckedCreateWithoutYoneticiOlduguOtellerInput = {
    id?: number
    ad: string
    soyad: string
    email: string
    telefon: string
    sifre: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    rezervasyonlar?: RezervasyonUncheckedCreateNestedManyWithoutMusteriInput
  }

  export type MusteriCreateOrConnectWithoutYoneticiOlduguOtellerInput = {
    where: MusteriWhereUniqueInput
    create: XOR<MusteriCreateWithoutYoneticiOlduguOtellerInput, MusteriUncheckedCreateWithoutYoneticiOlduguOtellerInput>
  }

  export type OdaCreateWithoutOtelInput = {
    numara: string
    tip: string
    fiyat: number
    kapasite: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rezervasyonlar?: RezervasyonCreateNestedManyWithoutOdaInput
    durumlar?: OdaDurumuCreateNestedManyWithoutOdaInput
  }

  export type OdaUncheckedCreateWithoutOtelInput = {
    id?: number
    numara: string
    tip: string
    fiyat: number
    kapasite: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rezervasyonlar?: RezervasyonUncheckedCreateNestedManyWithoutOdaInput
    durumlar?: OdaDurumuUncheckedCreateNestedManyWithoutOdaInput
  }

  export type OdaCreateOrConnectWithoutOtelInput = {
    where: OdaWhereUniqueInput
    create: XOR<OdaCreateWithoutOtelInput, OdaUncheckedCreateWithoutOtelInput>
  }

  export type OdaCreateManyOtelInputEnvelope = {
    data: OdaCreateManyOtelInput | OdaCreateManyOtelInput[]
    skipDuplicates?: boolean
  }

  export type MusteriUpsertWithoutYoneticiOlduguOtellerInput = {
    update: XOR<MusteriUpdateWithoutYoneticiOlduguOtellerInput, MusteriUncheckedUpdateWithoutYoneticiOlduguOtellerInput>
    create: XOR<MusteriCreateWithoutYoneticiOlduguOtellerInput, MusteriUncheckedCreateWithoutYoneticiOlduguOtellerInput>
    where?: MusteriWhereInput
  }

  export type MusteriUpdateToOneWithWhereWithoutYoneticiOlduguOtellerInput = {
    where?: MusteriWhereInput
    data: XOR<MusteriUpdateWithoutYoneticiOlduguOtellerInput, MusteriUncheckedUpdateWithoutYoneticiOlduguOtellerInput>
  }

  export type MusteriUpdateWithoutYoneticiOlduguOtellerInput = {
    ad?: StringFieldUpdateOperationsInput | string
    soyad?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefon?: StringFieldUpdateOperationsInput | string
    sifre?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rezervasyonlar?: RezervasyonUpdateManyWithoutMusteriNestedInput
  }

  export type MusteriUncheckedUpdateWithoutYoneticiOlduguOtellerInput = {
    id?: IntFieldUpdateOperationsInput | number
    ad?: StringFieldUpdateOperationsInput | string
    soyad?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefon?: StringFieldUpdateOperationsInput | string
    sifre?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rezervasyonlar?: RezervasyonUncheckedUpdateManyWithoutMusteriNestedInput
  }

  export type OdaUpsertWithWhereUniqueWithoutOtelInput = {
    where: OdaWhereUniqueInput
    update: XOR<OdaUpdateWithoutOtelInput, OdaUncheckedUpdateWithoutOtelInput>
    create: XOR<OdaCreateWithoutOtelInput, OdaUncheckedCreateWithoutOtelInput>
  }

  export type OdaUpdateWithWhereUniqueWithoutOtelInput = {
    where: OdaWhereUniqueInput
    data: XOR<OdaUpdateWithoutOtelInput, OdaUncheckedUpdateWithoutOtelInput>
  }

  export type OdaUpdateManyWithWhereWithoutOtelInput = {
    where: OdaScalarWhereInput
    data: XOR<OdaUpdateManyMutationInput, OdaUncheckedUpdateManyWithoutOtelInput>
  }

  export type OdaScalarWhereInput = {
    AND?: OdaScalarWhereInput | OdaScalarWhereInput[]
    OR?: OdaScalarWhereInput[]
    NOT?: OdaScalarWhereInput | OdaScalarWhereInput[]
    id?: IntFilter<"Oda"> | number
    numara?: StringFilter<"Oda"> | string
    tip?: StringFilter<"Oda"> | string
    fiyat?: FloatFilter<"Oda"> | number
    kapasite?: IntFilter<"Oda"> | number
    otelId?: IntFilter<"Oda"> | number
    createdAt?: DateTimeFilter<"Oda"> | Date | string
    updatedAt?: DateTimeFilter<"Oda"> | Date | string
  }

  export type OtelCreateWithoutOdalarInput = {
    ad: string
    adres: string
    sehir: string
    yildiz: number
    aciklama?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    yonetici: MusteriCreateNestedOneWithoutYoneticiOlduguOtellerInput
  }

  export type OtelUncheckedCreateWithoutOdalarInput = {
    id?: number
    ad: string
    adres: string
    sehir: string
    yildiz: number
    aciklama?: string | null
    yoneticiId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OtelCreateOrConnectWithoutOdalarInput = {
    where: OtelWhereUniqueInput
    create: XOR<OtelCreateWithoutOdalarInput, OtelUncheckedCreateWithoutOdalarInput>
  }

  export type RezervasyonCreateWithoutOdaInput = {
    girisTarihi: Date | string
    cikisTarihi: Date | string
    toplamFiyat: number
    durum?: $Enums.RezervasyonDurumu
    createdAt?: Date | string
    updatedAt?: Date | string
    musteri: MusteriCreateNestedOneWithoutRezervasyonlarInput
  }

  export type RezervasyonUncheckedCreateWithoutOdaInput = {
    id?: number
    musteriId: number
    girisTarihi: Date | string
    cikisTarihi: Date | string
    toplamFiyat: number
    durum?: $Enums.RezervasyonDurumu
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RezervasyonCreateOrConnectWithoutOdaInput = {
    where: RezervasyonWhereUniqueInput
    create: XOR<RezervasyonCreateWithoutOdaInput, RezervasyonUncheckedCreateWithoutOdaInput>
  }

  export type RezervasyonCreateManyOdaInputEnvelope = {
    data: RezervasyonCreateManyOdaInput | RezervasyonCreateManyOdaInput[]
    skipDuplicates?: boolean
  }

  export type OdaDurumuCreateWithoutOdaInput = {
    tarih: Date | string
    durum: $Enums.OdaDurumTipi
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OdaDurumuUncheckedCreateWithoutOdaInput = {
    id?: number
    tarih: Date | string
    durum: $Enums.OdaDurumTipi
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OdaDurumuCreateOrConnectWithoutOdaInput = {
    where: OdaDurumuWhereUniqueInput
    create: XOR<OdaDurumuCreateWithoutOdaInput, OdaDurumuUncheckedCreateWithoutOdaInput>
  }

  export type OdaDurumuCreateManyOdaInputEnvelope = {
    data: OdaDurumuCreateManyOdaInput | OdaDurumuCreateManyOdaInput[]
    skipDuplicates?: boolean
  }

  export type OtelUpsertWithoutOdalarInput = {
    update: XOR<OtelUpdateWithoutOdalarInput, OtelUncheckedUpdateWithoutOdalarInput>
    create: XOR<OtelCreateWithoutOdalarInput, OtelUncheckedCreateWithoutOdalarInput>
    where?: OtelWhereInput
  }

  export type OtelUpdateToOneWithWhereWithoutOdalarInput = {
    where?: OtelWhereInput
    data: XOR<OtelUpdateWithoutOdalarInput, OtelUncheckedUpdateWithoutOdalarInput>
  }

  export type OtelUpdateWithoutOdalarInput = {
    ad?: StringFieldUpdateOperationsInput | string
    adres?: StringFieldUpdateOperationsInput | string
    sehir?: StringFieldUpdateOperationsInput | string
    yildiz?: IntFieldUpdateOperationsInput | number
    aciklama?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yonetici?: MusteriUpdateOneRequiredWithoutYoneticiOlduguOtellerNestedInput
  }

  export type OtelUncheckedUpdateWithoutOdalarInput = {
    id?: IntFieldUpdateOperationsInput | number
    ad?: StringFieldUpdateOperationsInput | string
    adres?: StringFieldUpdateOperationsInput | string
    sehir?: StringFieldUpdateOperationsInput | string
    yildiz?: IntFieldUpdateOperationsInput | number
    aciklama?: NullableStringFieldUpdateOperationsInput | string | null
    yoneticiId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RezervasyonUpsertWithWhereUniqueWithoutOdaInput = {
    where: RezervasyonWhereUniqueInput
    update: XOR<RezervasyonUpdateWithoutOdaInput, RezervasyonUncheckedUpdateWithoutOdaInput>
    create: XOR<RezervasyonCreateWithoutOdaInput, RezervasyonUncheckedCreateWithoutOdaInput>
  }

  export type RezervasyonUpdateWithWhereUniqueWithoutOdaInput = {
    where: RezervasyonWhereUniqueInput
    data: XOR<RezervasyonUpdateWithoutOdaInput, RezervasyonUncheckedUpdateWithoutOdaInput>
  }

  export type RezervasyonUpdateManyWithWhereWithoutOdaInput = {
    where: RezervasyonScalarWhereInput
    data: XOR<RezervasyonUpdateManyMutationInput, RezervasyonUncheckedUpdateManyWithoutOdaInput>
  }

  export type OdaDurumuUpsertWithWhereUniqueWithoutOdaInput = {
    where: OdaDurumuWhereUniqueInput
    update: XOR<OdaDurumuUpdateWithoutOdaInput, OdaDurumuUncheckedUpdateWithoutOdaInput>
    create: XOR<OdaDurumuCreateWithoutOdaInput, OdaDurumuUncheckedCreateWithoutOdaInput>
  }

  export type OdaDurumuUpdateWithWhereUniqueWithoutOdaInput = {
    where: OdaDurumuWhereUniqueInput
    data: XOR<OdaDurumuUpdateWithoutOdaInput, OdaDurumuUncheckedUpdateWithoutOdaInput>
  }

  export type OdaDurumuUpdateManyWithWhereWithoutOdaInput = {
    where: OdaDurumuScalarWhereInput
    data: XOR<OdaDurumuUpdateManyMutationInput, OdaDurumuUncheckedUpdateManyWithoutOdaInput>
  }

  export type OdaDurumuScalarWhereInput = {
    AND?: OdaDurumuScalarWhereInput | OdaDurumuScalarWhereInput[]
    OR?: OdaDurumuScalarWhereInput[]
    NOT?: OdaDurumuScalarWhereInput | OdaDurumuScalarWhereInput[]
    id?: IntFilter<"OdaDurumu"> | number
    odaId?: IntFilter<"OdaDurumu"> | number
    tarih?: DateTimeFilter<"OdaDurumu"> | Date | string
    durum?: EnumOdaDurumTipiFilter<"OdaDurumu"> | $Enums.OdaDurumTipi
    createdAt?: DateTimeFilter<"OdaDurumu"> | Date | string
    updatedAt?: DateTimeFilter<"OdaDurumu"> | Date | string
  }

  export type MusteriCreateWithoutRezervasyonlarInput = {
    ad: string
    soyad: string
    email: string
    telefon: string
    sifre: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    yoneticiOlduguOteller?: OtelCreateNestedManyWithoutYoneticiInput
  }

  export type MusteriUncheckedCreateWithoutRezervasyonlarInput = {
    id?: number
    ad: string
    soyad: string
    email: string
    telefon: string
    sifre: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    yoneticiOlduguOteller?: OtelUncheckedCreateNestedManyWithoutYoneticiInput
  }

  export type MusteriCreateOrConnectWithoutRezervasyonlarInput = {
    where: MusteriWhereUniqueInput
    create: XOR<MusteriCreateWithoutRezervasyonlarInput, MusteriUncheckedCreateWithoutRezervasyonlarInput>
  }

  export type OdaCreateWithoutRezervasyonlarInput = {
    numara: string
    tip: string
    fiyat: number
    kapasite: number
    createdAt?: Date | string
    updatedAt?: Date | string
    otel: OtelCreateNestedOneWithoutOdalarInput
    durumlar?: OdaDurumuCreateNestedManyWithoutOdaInput
  }

  export type OdaUncheckedCreateWithoutRezervasyonlarInput = {
    id?: number
    numara: string
    tip: string
    fiyat: number
    kapasite: number
    otelId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    durumlar?: OdaDurumuUncheckedCreateNestedManyWithoutOdaInput
  }

  export type OdaCreateOrConnectWithoutRezervasyonlarInput = {
    where: OdaWhereUniqueInput
    create: XOR<OdaCreateWithoutRezervasyonlarInput, OdaUncheckedCreateWithoutRezervasyonlarInput>
  }

  export type MusteriUpsertWithoutRezervasyonlarInput = {
    update: XOR<MusteriUpdateWithoutRezervasyonlarInput, MusteriUncheckedUpdateWithoutRezervasyonlarInput>
    create: XOR<MusteriCreateWithoutRezervasyonlarInput, MusteriUncheckedCreateWithoutRezervasyonlarInput>
    where?: MusteriWhereInput
  }

  export type MusteriUpdateToOneWithWhereWithoutRezervasyonlarInput = {
    where?: MusteriWhereInput
    data: XOR<MusteriUpdateWithoutRezervasyonlarInput, MusteriUncheckedUpdateWithoutRezervasyonlarInput>
  }

  export type MusteriUpdateWithoutRezervasyonlarInput = {
    ad?: StringFieldUpdateOperationsInput | string
    soyad?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefon?: StringFieldUpdateOperationsInput | string
    sifre?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yoneticiOlduguOteller?: OtelUpdateManyWithoutYoneticiNestedInput
  }

  export type MusteriUncheckedUpdateWithoutRezervasyonlarInput = {
    id?: IntFieldUpdateOperationsInput | number
    ad?: StringFieldUpdateOperationsInput | string
    soyad?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefon?: StringFieldUpdateOperationsInput | string
    sifre?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yoneticiOlduguOteller?: OtelUncheckedUpdateManyWithoutYoneticiNestedInput
  }

  export type OdaUpsertWithoutRezervasyonlarInput = {
    update: XOR<OdaUpdateWithoutRezervasyonlarInput, OdaUncheckedUpdateWithoutRezervasyonlarInput>
    create: XOR<OdaCreateWithoutRezervasyonlarInput, OdaUncheckedCreateWithoutRezervasyonlarInput>
    where?: OdaWhereInput
  }

  export type OdaUpdateToOneWithWhereWithoutRezervasyonlarInput = {
    where?: OdaWhereInput
    data: XOR<OdaUpdateWithoutRezervasyonlarInput, OdaUncheckedUpdateWithoutRezervasyonlarInput>
  }

  export type OdaUpdateWithoutRezervasyonlarInput = {
    numara?: StringFieldUpdateOperationsInput | string
    tip?: StringFieldUpdateOperationsInput | string
    fiyat?: FloatFieldUpdateOperationsInput | number
    kapasite?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otel?: OtelUpdateOneRequiredWithoutOdalarNestedInput
    durumlar?: OdaDurumuUpdateManyWithoutOdaNestedInput
  }

  export type OdaUncheckedUpdateWithoutRezervasyonlarInput = {
    id?: IntFieldUpdateOperationsInput | number
    numara?: StringFieldUpdateOperationsInput | string
    tip?: StringFieldUpdateOperationsInput | string
    fiyat?: FloatFieldUpdateOperationsInput | number
    kapasite?: IntFieldUpdateOperationsInput | number
    otelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durumlar?: OdaDurumuUncheckedUpdateManyWithoutOdaNestedInput
  }

  export type OdaCreateWithoutDurumlarInput = {
    numara: string
    tip: string
    fiyat: number
    kapasite: number
    createdAt?: Date | string
    updatedAt?: Date | string
    otel: OtelCreateNestedOneWithoutOdalarInput
    rezervasyonlar?: RezervasyonCreateNestedManyWithoutOdaInput
  }

  export type OdaUncheckedCreateWithoutDurumlarInput = {
    id?: number
    numara: string
    tip: string
    fiyat: number
    kapasite: number
    otelId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rezervasyonlar?: RezervasyonUncheckedCreateNestedManyWithoutOdaInput
  }

  export type OdaCreateOrConnectWithoutDurumlarInput = {
    where: OdaWhereUniqueInput
    create: XOR<OdaCreateWithoutDurumlarInput, OdaUncheckedCreateWithoutDurumlarInput>
  }

  export type OdaUpsertWithoutDurumlarInput = {
    update: XOR<OdaUpdateWithoutDurumlarInput, OdaUncheckedUpdateWithoutDurumlarInput>
    create: XOR<OdaCreateWithoutDurumlarInput, OdaUncheckedCreateWithoutDurumlarInput>
    where?: OdaWhereInput
  }

  export type OdaUpdateToOneWithWhereWithoutDurumlarInput = {
    where?: OdaWhereInput
    data: XOR<OdaUpdateWithoutDurumlarInput, OdaUncheckedUpdateWithoutDurumlarInput>
  }

  export type OdaUpdateWithoutDurumlarInput = {
    numara?: StringFieldUpdateOperationsInput | string
    tip?: StringFieldUpdateOperationsInput | string
    fiyat?: FloatFieldUpdateOperationsInput | number
    kapasite?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otel?: OtelUpdateOneRequiredWithoutOdalarNestedInput
    rezervasyonlar?: RezervasyonUpdateManyWithoutOdaNestedInput
  }

  export type OdaUncheckedUpdateWithoutDurumlarInput = {
    id?: IntFieldUpdateOperationsInput | number
    numara?: StringFieldUpdateOperationsInput | string
    tip?: StringFieldUpdateOperationsInput | string
    fiyat?: FloatFieldUpdateOperationsInput | number
    kapasite?: IntFieldUpdateOperationsInput | number
    otelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rezervasyonlar?: RezervasyonUncheckedUpdateManyWithoutOdaNestedInput
  }

  export type RezervasyonCreateManyMusteriInput = {
    id?: number
    odaId: number
    girisTarihi: Date | string
    cikisTarihi: Date | string
    toplamFiyat: number
    durum?: $Enums.RezervasyonDurumu
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OtelCreateManyYoneticiInput = {
    id?: number
    ad: string
    adres: string
    sehir: string
    yildiz: number
    aciklama?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RezervasyonUpdateWithoutMusteriInput = {
    girisTarihi?: DateTimeFieldUpdateOperationsInput | Date | string
    cikisTarihi?: DateTimeFieldUpdateOperationsInput | Date | string
    toplamFiyat?: FloatFieldUpdateOperationsInput | number
    durum?: EnumRezervasyonDurumuFieldUpdateOperationsInput | $Enums.RezervasyonDurumu
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    oda?: OdaUpdateOneRequiredWithoutRezervasyonlarNestedInput
  }

  export type RezervasyonUncheckedUpdateWithoutMusteriInput = {
    id?: IntFieldUpdateOperationsInput | number
    odaId?: IntFieldUpdateOperationsInput | number
    girisTarihi?: DateTimeFieldUpdateOperationsInput | Date | string
    cikisTarihi?: DateTimeFieldUpdateOperationsInput | Date | string
    toplamFiyat?: FloatFieldUpdateOperationsInput | number
    durum?: EnumRezervasyonDurumuFieldUpdateOperationsInput | $Enums.RezervasyonDurumu
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RezervasyonUncheckedUpdateManyWithoutMusteriInput = {
    id?: IntFieldUpdateOperationsInput | number
    odaId?: IntFieldUpdateOperationsInput | number
    girisTarihi?: DateTimeFieldUpdateOperationsInput | Date | string
    cikisTarihi?: DateTimeFieldUpdateOperationsInput | Date | string
    toplamFiyat?: FloatFieldUpdateOperationsInput | number
    durum?: EnumRezervasyonDurumuFieldUpdateOperationsInput | $Enums.RezervasyonDurumu
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtelUpdateWithoutYoneticiInput = {
    ad?: StringFieldUpdateOperationsInput | string
    adres?: StringFieldUpdateOperationsInput | string
    sehir?: StringFieldUpdateOperationsInput | string
    yildiz?: IntFieldUpdateOperationsInput | number
    aciklama?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    odalar?: OdaUpdateManyWithoutOtelNestedInput
  }

  export type OtelUncheckedUpdateWithoutYoneticiInput = {
    id?: IntFieldUpdateOperationsInput | number
    ad?: StringFieldUpdateOperationsInput | string
    adres?: StringFieldUpdateOperationsInput | string
    sehir?: StringFieldUpdateOperationsInput | string
    yildiz?: IntFieldUpdateOperationsInput | number
    aciklama?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    odalar?: OdaUncheckedUpdateManyWithoutOtelNestedInput
  }

  export type OtelUncheckedUpdateManyWithoutYoneticiInput = {
    id?: IntFieldUpdateOperationsInput | number
    ad?: StringFieldUpdateOperationsInput | string
    adres?: StringFieldUpdateOperationsInput | string
    sehir?: StringFieldUpdateOperationsInput | string
    yildiz?: IntFieldUpdateOperationsInput | number
    aciklama?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OdaCreateManyOtelInput = {
    id?: number
    numara: string
    tip: string
    fiyat: number
    kapasite: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OdaUpdateWithoutOtelInput = {
    numara?: StringFieldUpdateOperationsInput | string
    tip?: StringFieldUpdateOperationsInput | string
    fiyat?: FloatFieldUpdateOperationsInput | number
    kapasite?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rezervasyonlar?: RezervasyonUpdateManyWithoutOdaNestedInput
    durumlar?: OdaDurumuUpdateManyWithoutOdaNestedInput
  }

  export type OdaUncheckedUpdateWithoutOtelInput = {
    id?: IntFieldUpdateOperationsInput | number
    numara?: StringFieldUpdateOperationsInput | string
    tip?: StringFieldUpdateOperationsInput | string
    fiyat?: FloatFieldUpdateOperationsInput | number
    kapasite?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rezervasyonlar?: RezervasyonUncheckedUpdateManyWithoutOdaNestedInput
    durumlar?: OdaDurumuUncheckedUpdateManyWithoutOdaNestedInput
  }

  export type OdaUncheckedUpdateManyWithoutOtelInput = {
    id?: IntFieldUpdateOperationsInput | number
    numara?: StringFieldUpdateOperationsInput | string
    tip?: StringFieldUpdateOperationsInput | string
    fiyat?: FloatFieldUpdateOperationsInput | number
    kapasite?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RezervasyonCreateManyOdaInput = {
    id?: number
    musteriId: number
    girisTarihi: Date | string
    cikisTarihi: Date | string
    toplamFiyat: number
    durum?: $Enums.RezervasyonDurumu
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OdaDurumuCreateManyOdaInput = {
    id?: number
    tarih: Date | string
    durum: $Enums.OdaDurumTipi
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RezervasyonUpdateWithoutOdaInput = {
    girisTarihi?: DateTimeFieldUpdateOperationsInput | Date | string
    cikisTarihi?: DateTimeFieldUpdateOperationsInput | Date | string
    toplamFiyat?: FloatFieldUpdateOperationsInput | number
    durum?: EnumRezervasyonDurumuFieldUpdateOperationsInput | $Enums.RezervasyonDurumu
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    musteri?: MusteriUpdateOneRequiredWithoutRezervasyonlarNestedInput
  }

  export type RezervasyonUncheckedUpdateWithoutOdaInput = {
    id?: IntFieldUpdateOperationsInput | number
    musteriId?: IntFieldUpdateOperationsInput | number
    girisTarihi?: DateTimeFieldUpdateOperationsInput | Date | string
    cikisTarihi?: DateTimeFieldUpdateOperationsInput | Date | string
    toplamFiyat?: FloatFieldUpdateOperationsInput | number
    durum?: EnumRezervasyonDurumuFieldUpdateOperationsInput | $Enums.RezervasyonDurumu
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RezervasyonUncheckedUpdateManyWithoutOdaInput = {
    id?: IntFieldUpdateOperationsInput | number
    musteriId?: IntFieldUpdateOperationsInput | number
    girisTarihi?: DateTimeFieldUpdateOperationsInput | Date | string
    cikisTarihi?: DateTimeFieldUpdateOperationsInput | Date | string
    toplamFiyat?: FloatFieldUpdateOperationsInput | number
    durum?: EnumRezervasyonDurumuFieldUpdateOperationsInput | $Enums.RezervasyonDurumu
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OdaDurumuUpdateWithoutOdaInput = {
    tarih?: DateTimeFieldUpdateOperationsInput | Date | string
    durum?: EnumOdaDurumTipiFieldUpdateOperationsInput | $Enums.OdaDurumTipi
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OdaDurumuUncheckedUpdateWithoutOdaInput = {
    id?: IntFieldUpdateOperationsInput | number
    tarih?: DateTimeFieldUpdateOperationsInput | Date | string
    durum?: EnumOdaDurumTipiFieldUpdateOperationsInput | $Enums.OdaDurumTipi
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OdaDurumuUncheckedUpdateManyWithoutOdaInput = {
    id?: IntFieldUpdateOperationsInput | number
    tarih?: DateTimeFieldUpdateOperationsInput | Date | string
    durum?: EnumOdaDurumTipiFieldUpdateOperationsInput | $Enums.OdaDurumTipi
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use MusteriCountOutputTypeDefaultArgs instead
     */
    export type MusteriCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MusteriCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OtelCountOutputTypeDefaultArgs instead
     */
    export type OtelCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OtelCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OdaCountOutputTypeDefaultArgs instead
     */
    export type OdaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OdaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MusteriDefaultArgs instead
     */
    export type MusteriArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MusteriDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OtelDefaultArgs instead
     */
    export type OtelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OtelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OdaDefaultArgs instead
     */
    export type OdaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OdaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RezervasyonDefaultArgs instead
     */
    export type RezervasyonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RezervasyonDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OdaDurumuDefaultArgs instead
     */
    export type OdaDurumuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OdaDurumuDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}